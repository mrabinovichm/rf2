/*** BeginHeader rfid_layer2_iso14443A */

#define	ISO14443A_BITOFCOL_NONE		0xFF
#define  CT 0x88
#define  ATQ_SIZE 2
#define  SAK_SIZE 1

/*Definitions in standard ISO14443*/

enum rfid_14443_opt_speed {
	RFID_14443A_SPEED_106K	= 0x01,
	RFID_14443A_SPEED_212K	= 0x02,
	RFID_14443A_SPEED_424K  = 0x04,
	RFID_14443A_SPEED_848K  = 0x08,
};

/* protocol definitions */

/* ISO 14443-3, Chapter 6.3.1 */
enum iso14443a_sf_cmd {
	ISO14443A_SF_CMD_REQA		   = 0x26,
	ISO14443A_SF_CMD_WUPA		   = 0x52,
	ISO14443A_SF_CMD_OPT_TIMESLOT	= 0x35,		/* Annex C */
	/* 40 to 4f and 78 to 7f: proprietary */
};

struct iso14443a_atqa {

	byte lwByte; /*UIDsize[7 6] RFU[5] Bit Frame Anticollision[4..0]*/
	byte hiByte; /*RFU[7..4] Propietary[3..0]*/

};

/*Byte MSB in commands Anticollition and Select*/
enum iso14443a_anticol_sel_code {
	ISO14443A_AC_SEL_CODE_CL1	= 0x93,
	ISO14443A_AC_SEL_CODE_CL2	= 0x95,
	ISO14443A_AC_SEL_CODE_CL3	= 0x97,
};

/*Cascade Level*/
enum iso14443a_level {
	ISO14443A_LEVEL_NONE,
	ISO14443A_LEVEL_CL1,
	ISO14443A_LEVEL_CL2,
	ISO14443A_LEVEL_CL3,
};

enum iso14443a_state {
	ISO14443A_STATE_ERROR,
	ISO14443A_STATE_NONE,
	ISO14443A_STATE_REQA_SENT,
	ISO14443A_STATE_ATQA_RCVD,
	ISO14443A_STATE_NO_BITFRAME_ANTICOL,
	ISO14443A_STATE_ANTICOL_RUNNING,
	ISO14443A_STATE_SELECTED,
};

/*** EndHeader */



/*** BeginHeader iso14443a_request */
byte iso14443a_request(byte cmd_code, byte *atq, byte *atq_len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_request                <RFID_LAYER2_ISO14443A.LIB>

SYNTAX:			byte iso14443a_request(byte cmd_code, byte *atq, byte *atq_len);

DESCRIPTION:   Ejecuta el comando "Request" de la norma ISO14443

PARAMETER1:    Comando a ser enviado a la tarjeta.
PARAMETER2:    Respuesta de la tarjeta, ATQ.
PARAMETER3:    Longitud de datos recibidos.

RETURN:			Estado de las banderas del RC632 (0x00 = OK).

END DESCRIPTION **********************************************************/
byte iso14443a_request(byte cmd_code, byte *atq, byte *atq_len)
{
	byte send[1];
/*Configuracion para enviar comando REQUEST*/
/*Without crypto1*/
	rc632_clear_bit_mask(RC632_REG_CONTROL, RC632_CONTROL_CRYPTO1_ON);
/*Transfer only 7 bits of last byte in frame */
	rc632_reg_write(RC632_REG_BIT_FRAMING, 0x07);
/*No Tx CRC, Rx CRC*/
   rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x03);

   send[0] = cmd_code;
   return rc632_transceive(send, 1, atq, atq_len);
}

/*************************************************************************/



/*** BeginHeader iso14443a_anticollition */
byte iso14443a_anticollition(byte cmd_code, byte *ct_uid_bcc, byte *ct_uid_bcc_len, byte *cksum);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_anticollition                <RFID_LAYER2_ISO14443A.LIB>

SYNTAX:			byte iso14443a_anticollition(byte cmd_code, byte *ct_uid_bcc, byte *ct_uid_bcc_len, byte *cksum);

DESCRIPTION:   Ejecuta el comando "Anticollition" de la norma ISO14443

PARAMETER1:    Comando a ser enviado a la tarjeta.
PARAMETER2:    Respuesta de la tarjeta, CT+UID+BCC.
PARAMETER3:    Longitud de datos recibidos.
PARAMETER4:    Checksum calculado a partir del EXOR de CT+UID(debe ser igual a BCC).

RETURN:			Estado de las banderas del RC632 (0x00 = OK).

END DESCRIPTION **********************************************************/
byte iso14443a_anticollition(byte cmd_code, byte *ct_uid_bcc, byte *ct_uid_bcc_len, byte *cksum)
{
	byte send[2], status;
/*Configuracion para enviar comando Anticollition CL*/
/*Without crypto1*/
	rc632_clear_bit_mask(RC632_REG_CONTROL, RC632_CONTROL_CRYPTO1_ON);
/*No Tx CRC, Rx CRC*/
   rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x03);

   send[0] = cmd_code;
	send[1] = 0x20;
   status = rc632_transceive(send, 2, ct_uid_bcc, ct_uid_bcc_len);
   *cksum = ct_uid_bcc[0]^ct_uid_bcc[1]^ct_uid_bcc[2]^ct_uid_bcc[3];
   return status;
}

/*************************************************************************/



/*** BeginHeader iso14443a_select */
byte iso14443a_select(byte cmd_code, byte *ct_uid_bcc, byte *sak, byte *sak_len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_select                <RFID_LAYER2_ISO14443A.LIB>

SYNTAX:			byte iso14443a_select(byte cmd_code, byte *ct_uid_bcc, byte *sak, byte *sak_len);

DESCRIPTION:   Ejecuta el comando "Select" de la norma ISO14443

PARAMETER1:    Comando a ser enviado a la tarjeta.
PARAMETER2:    Respuesta de la tarjeta, SAK.
PARAMETER3:    Longitud de datos recibidos.

RETURN:			Estado de las banderas del RC632 (0x00 = OK).

END DESCRIPTION **********************************************************/
byte iso14443a_select(byte cmd_code, byte *ct_uid_bcc, byte *sak, byte *sak_len)
{
	byte send[7];
/*Configuracion para enviar comando Select CL*/
/*Without crypto1*/
	rc632_clear_bit_mask(RC632_REG_CONTROL, RC632_CONTROL_CRYPTO1_ON);
/*Enable Tx CRC, Rx CRC*/
   rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x0F);

   send[0] = cmd_code;
   send[1] = 0x70;
   send[2] = ct_uid_bcc[0];        /*Adjunto la respuesta de la tarjeta*/
   send[3] = ct_uid_bcc[1];
   send[4] = ct_uid_bcc[2];
   send[5] = ct_uid_bcc[3];
   send[6] = ct_uid_bcc[4];

   return rc632_transceive(send, 7, sak, sak_len);
}

/*************************************************************************/



/*** BeginHeader iso14443a_activ_secuence */
byte iso14443a_activ_secuence(byte cmd_code, byte *atq, byte *uid, byte *uid_len, byte *sak);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_activ_secuence                <RFID_LAYER2_ISO14443A.LIB>

SYNTAX:			byte iso14443a_activ_secuence(byte cmd_code, byte *atq, byte *uid, byte *uid_len, byte *sak);

DESCRIPTION:   Ejecuta el algoritmo para la activacion de tarjetas ISO14443A.

PARAMETER1:    Comando a ser enviado a la tarjeta (REQ_A o WUPA).
PARAMETER2:    ATQ de la tarjeta.
PARAMETER3:    UID de la tarjeta.
PARAMETER4:    Longitud UID de la tarjeta (4, 7 o 10 bytes).
PARAMETER5:    SAK de la tarjeta.

RETURN:			Estado de las banderas del RC632 (0x00 = OK).

END DESCRIPTION **********************************************************/
byte iso14443a_activ_secuence(byte cmd_code, byte *atq, byte *uid, byte *uid_len, byte *sak)
{
	byte  atq_len[1], CtUidBcc[5], CtUidBcc_len[1], sak_len[1];
   byte status, bcc, checksum, ac_sel_code_CL;
   short complete, level;

   status = iso14443a_request(cmd_code, atq, atq_len);
   if((status == 0x00) && (atq[0] & 0x1F))   /*status OK; Bit Frame Anticollition suported*/
   {
   	level = ISO14443A_LEVEL_CL1;
   	complete = 0;
   	while(!complete)
   	{
      	switch(level)
         {
         	case ISO14443A_LEVEL_CL1: ac_sel_code_CL = ISO14443A_AC_SEL_CODE_CL1; *uid_len = 4;  break;
            case ISO14443A_LEVEL_CL2: ac_sel_code_CL = ISO14443A_AC_SEL_CODE_CL2; *uid_len = 7;  break;
            case ISO14443A_LEVEL_CL3: ac_sel_code_CL = ISO14443A_AC_SEL_CODE_CL3; *uid_len = 10; break;
            default: printf("Error Cascade Level\n");
         }
   		status = iso14443a_anticollition(ac_sel_code_CL, CtUidBcc, CtUidBcc_len, &checksum);
			/*printf("Checksum OK: %02X\n", checksum);*/
   		bcc = CtUidBcc[4];
   		if(bcc == checksum)
         {
				status = iso14443a_select(ac_sel_code_CL, CtUidBcc, sak, sak_len);
   			if(CtUidBcc[0] != CT)
            {
            	complete = 1;
               CtUidBcc[4] = '\0';           /*descarto el byte BCC*/
               strcpy(uid, CtUidBcc);
            }
     			else
            {
         		level++;
               CtUidBcc[4] = '\0';           /*descarto el byte BCC*/
               strcpy(uid, CtUidBcc+1);      /*copio sin el byte CT*/
            }
         }
         else
         	printf("Error Checksum\n");
      }
   }
   return status;
}

/*************************************************************************/
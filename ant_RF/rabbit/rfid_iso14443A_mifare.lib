/*** BeginHeader rfid_iso14443A_mifare */


#define ERROR_FLAG         0x01
#define ERROR_CRYPTO1_ON   0x02
#define ERROR_RX_LAST_BITS 0x03
#define ERROR_READ			0x04
#define ERROR_LENGTH       0x05
#define ERROR_WRITE        0x06
#define ERROR_ACCESS       0x07
#define ERROR_NACK         0x08

#define ERROR_CASCADE		0X81
#define ERROR_CHECKSUM     0X82

/*** EndHeader */



/*** BeginHeader iso14443a_authentication */
byte iso14443a_authentication(byte auth_cmd, byte block, byte *key_mifare, byte *uid);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_authentication                <RFID_ASIC_RC632.LIB>

SYNTAX:			byte iso14443a_authentication(byte auth_cmd, byte block, byte *key_mifare, byte *uid);

DESCRIPTION:   Autentica el IC RC632 con una tarjeta MIFARE.

PARAMETER1:    Comando de autenticacion de la tarjeta,
					clave tipoA=0x60, tipoB=0x61.
PARAMETER2:    Bloque de la tarjeta con el cual se autentica.
PARAMETER3:    Clave MIFARE del sector al que pertenece el bloque.
PARAMETER4:    Numero de serie de la tarjeta.

END DESCRIPTION **********************************************************/
byte iso14443a_authentication(byte auth_cmd, byte block, byte *key_mifare, byte *uid)
{
   byte sndbuf[6], flags, status;
   int i;

	sndbuf[0] = auth_cmd;
	sndbuf[1] = block;

	for(i=0; i<4; i++)
   {
   	sndbuf[i+2] = *(uid+i);
	}
   /*Almacena la clave del sector en el key buffer*/
   flags = rc632_storage_key_buffer(key_mifare);

   if(flags == OK)
   {
		/*No Rx CRC, Enable Tx CRC, and odd parity*/
   	rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x07);
      /*Reset FIFO buffer*/
      reset_FIFO_buffer();
      /*Carga el buffer FIFO y calcula su CRC*/
		rc632_fifo_write(sndbuf, 6);
   	rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_CALC_CRC);
   	do
   	{
      	rc632_reg_read(RC632_REG_SECONDARY_STATUS, &status);
      	status &= 0x20;
   	} while(status == 0x00);    /*Espera a que el bit CRCReady sea "1"*/
   	rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_IDLE);
      /* Authent1 Command */
		rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_AUTHENT1);

   	rc632_reg_read(RC632_REG_SECONDARY_STATUS, &status);
   	if(status & 0x07)
   		return ERROR_RX_LAST_BITS;     /*Invalid last received byte*/
   	else
   	{  /*No Tx CRC, Rx CRC*/
			rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x03);
      	/* Authent2 Command */
			rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_AUTHENT2);
    		/*Check whether authentication was successful*/
   		rc632_reg_read(RC632_REG_CONTROL, &status);
   		if(status & RC632_CONTROL_CRYPTO1_ON)
   			return OK;
   	}
   }
   return flags;
}
/*************************************************************************/



/*** BeginHeader iso14443a_read */
byte iso14443a_read(byte cmd, byte block, byte *data, byte *data_len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_read                <RFID_ASIC_RC632.LIB>

SYNTAX:			byte iso14443a_read(byte cmd, byte block, byte *data, byte data_len);

DESCRIPTION:   Lee los 16 bytes de un bloque de una tarjeta MIFARE.

PARAMETER1:    Comando de lectura de tarjetas. 0x30
PARAMETER2:    Bloque de la tarjeta que se quiere leer.
PARAMETER3:    Datos devueltos por la tarjeta.
PARAMETER4:    Longitud de un bloque de la tarjeta.

END DESCRIPTION **********************************************************/
byte iso14443a_read(byte cmd, byte block, byte *data, byte *data_len)
{
   byte sndbuf[2], receive[64], rec_len, status;
   int i;

	reset_FIFO_buffer();

	/*Enable Rx CRC, Tx CRC, and odd parity*/
	rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x0F);

	sndbuf[0] = cmd;
	sndbuf[1] = block;
#if 0
	status = rc632_transceive(sndbuf, 2, receive, &rec_len);

	if (status == 0x00)
	{
		if(rec_len != data_len)
		{
			/*De todas formas copio los datos recibidos*/
			if (rec_len >= data_len)
			{
				for (i = 0; i < data_len; i++)
				{
					data[i] = receive[i];
				}
			}
			else
			{
				for (i = 0; i < rec_len; i++)
				{
					data[i] = receive[i];
				}
				for (i = rec_len; i < data_len; i++)
				{
					data[i] = 0x00;
				}
			}
		}
		else
		{
			for (i = 0; i < data_len; i++)
			{
				data[i] = receive[i];
			}
		}
	}
#endif
	reset_FIFO_buffer();
	status = rc632_transceive_CRC(sndbuf, 2, data, data_len);
	return status;
}
/*************************************************************************/



/*** BeginHeader iso14443a_write */
byte iso14443a_write(byte cmd, byte block, byte *data, byte *data_len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
iso14443a_write                <RFID_ASIC_RC632.LIB>

SYNTAX:			byte iso14443a_write(byte cmd, byte block, byte *data, byte *data_len);

DESCRIPTION:   Lee los 16 bytes de un bloque de una tarjeta MIFARE.

PARAMETER1:    Comando de escritura de tarjetas. 0xA0
PARAMETER2:    Bloque de la tarjeta que se quiere escribir.
PARAMETER3:    Datos a escribir en la tarjeta.
PARAMETER4:    Longitud de los datos a escribir.

END DESCRIPTION **********************************************************/
byte iso14443a_write(byte cmd, byte block, byte *data, byte *data_len)
{
   byte sndbuf[64], receive[1], rec_len, flags, status;
   int i;

	reset_FIFO_buffer();

	/*No Rx CRC, Enable Tx CRC, and odd parity*/
	rc632_reg_write(RC632_REG_CHANNEL_REDUNDANCY, 0x07);

	sndbuf[0] = cmd;
	sndbuf[1] = block;
	status = rc632_transceive(sndbuf, 2, receive, &rec_len);

	if (status != 0x00)
		status = ERROR_WRITE;
	else
	{
		receive[0] &= 0x0f; /*Lower nibble ACK/NACK*/
		switch(receive[0])
		{
			case 0x00: status = ERROR_ACCESS; break;
			case 0x0a: status = OK;			  	 break;
			default:   satuts = ERROR_NACK;   break;
		}
		if(status == OK)
			status = rc632_transceive(data, *data_len, receive, rec_len);
	}
	return status;
}
/*************************************************************************/



/*** BeginHeader rc632_transceive_CRC */
byte rc632_transceive_CRC(byte *tx_buff, byte tx_len, byte *rx_buff, byte *rx_len);
/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
rc632_transceive                <RFID_ASIC_RC632.LIB>

SYNTAX:			byte rc632_transceive_CRC(byte *tx_buff, byte tx_len, byte *rx_buff, byte *rx_len);

DESCRIPTION:   Transmision de datos desde el IC RC632 y recepcion de los datos
					en respuesta desde una tarjeta RF.

PARAMETER1:    Datos a ser transmitidos.
PARAMETER2:    Longitud de datos a transmitir.
PARAMETER3:    Datos a ser recibidos.
PARAMETER4:    Longitud de datos recibidos.

RETURN:			Estado de las banderas del RC632 (0x00 = OK).

END DESCRIPTION **********************************************************/
byte rc632_transceive_CRC(byte *tx_buff, byte tx_len, byte *rx_buff, byte *rx_len)
{
	byte flags, modemState, status;

	/*Idle state*/
   rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_IDLE);
	/*Clear all interrupts and errors flags*/
	rc632_reg_write(RC632_REG_INTERRUPT_RQ, 0x00);
	rc632_reg_write(RC632_REG_ERROR_FLAG, 0x00);

	rc632_fifo_write(tx_buff, tx_len);
#if 1
   rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_CALC_CRC);
   do
   {
      rc632_reg_read(RC632_REG_SECONDARY_STATUS, &status);
      status &= 0x20;
   } while(status == 0x00);    /*Espera a que el bit CRCReady sea "1"*/
   rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_IDLE);
#endif

   rc632_reg_write(RC632_REG_COMMAND, RC632_CMD_TRANSCEIVE);
   do
   {
  		rc632_reg_read(RC632_REG_PRIMARY_STATUS, &modemState);
      modemState &= 0x70;
   } while(modemState);          /*Espera hasta que el modem queda ocioso*/

   /*Check errors*/
   rc632_reg_read(RC632_REG_ERROR_FLAG, &flags);
   if(flags &= 0x0F) return flags;

   rc632_reg_read(RC632_REG_FIFO_LENGTH, rx_len);
   rc632_fifo_read(rx_buff, rx_len[0]);

   return 0x00;
}
/*************************************************************************/


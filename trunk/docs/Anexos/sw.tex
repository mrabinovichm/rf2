\chapter{Software}\label{anx_sw}

\section{OpenEmbedded-Bitbake}\label{anx_sw_oe}

Para la instalación, configuración y ejecución de esta herramienta, se deben seguir los pasos en detalle. Se debe tener una buena conexión a internet para la descarga de fuentes, espacio libre en disco duro de no menos de 10GB, buen procesador y paciencia ya que los desarrollos completos demoran varias horas.

\bigskip
Primero se instalan los paquetes previos necesarios. 

\bigskip
Paquetes importantes:

\bigskip
\centerline{\$ sudo apt-get install sed wget cvs subversion git-core $\backslash$}

\centerline{coreutils unzip texi2html texinfo docbook-utils $\backslash$}

\centerline{gawk python-pysqlite2 diffstat help2man make gcc build-essential g++ $\backslash$}

\centerline{desktop-file-utils chrpath}

\bigskip
Paquetes secundarios (aceleran los procesos):

\bigskip
\centerline{\$ sudo apt-get install libxml2-utils xmlto python-psyco apr}

\newpage
Chequear que /bin/sh no tiene un enlace simbólico a “dash”:

\bigskip
\centerline{\$ ls -l /bin/sh}

\bigskip
Debe estar enlazado a “bash”. Si no lo está:

\bigskip
\centerline{\$ sudo dpkg-reconfigure dash}

\bigskip
Aquí seleccionamos NO instalar “dash” como /bin/sh

\bigskip
Compilador para aumentar la velocidad de bitbake:

\bigskip
\centerline{\$ sudo apt-get install python-psyco}

\bigskip
Para versiones de Ubuntu mayores o iguales a la 10.04:

\bigskip
\centerline{\$ sudo su}

\centerline{\$ echo 128 $>$ /proc/sys/vm/mmap\_min\_addr}

\centerline{\$ exit}

\centerline{\$ sudo sysctl -w vm.mmap\_min\_addr=128}


\leftline{Instalación:}

\bigskip
El directorio base seleccionado para el desarrollo con OpenEmbedded es stuff (puede ser otro), y se ubicó en /.

\bigskip
Se crea la estructura de directorios:

\bigskip
\centerline{\$ sudo mkdir -p /stuff/build/conf}

\centerline{\$ cd /stuff/}

\bigskip
Bitbake es la herramienta de construcción que utiliza OpenEmbedded. Está escrita en Python, por lo que no es necesario compilarlo para que funcione.

\bigskip
\centerline{\$ sudo wget http://download.berlios.de/bitbake/bitbake-1.10.2.tar.gz}

\bigskip
Nota: esta es la última versión disponible al momento. Para saber cual es la última versión disponible, entrar a: http://download.berlios.de/bitbake/.

Para las nuevas versiones es necesario tener instalado Python 2.6 o posterior.

\newpage
Luego se descomprime el tar.gz bajado:

\bigskip
\centerline{\$ sudo tar -xzf bitbake-1.10.2.tar.gz}

\centerline{\$ ls}

\bigskip
Se debe ver un directorio llamado en este caso bitbake-1.10.2 (se puede renombrar a: “bitbake” por comodidad).

\bigskip
Para obtener OpenEmbedded es necesario tener instalado git.

\bigskip
Ahora se hace lo siguiente:

\bigskip
\centerline{\$ cd /stuff}

\centerline{\$ sudo git clone git://git.openembedded.org/openembedded}

\bigskip
Nota: git clone es para hacer un checkout del repositorio. 

Otro repositorio es http://repo.or.cz/r/openembedded.git

\bigskip
Demora mucho. Al finalizar se crea un directorio con el nombre openembedded.

\bigskip
Se recomienda actualizar OpenEmbedded una vez al día:

\bigskip
\centerline{\$ cd /stuff/openembedded}

\centerline{\$ sudo git pull}

\bigskip
\leftline{Configuración:}

\bigskip
Se modifica la configuración local, donde se debe indicar todo lo que se quiera crear.

\bigskip
\centerline{\$ cd /stuff/}

\centerline{\$ sudo cp openembedded/conf/local.conf.sample build/conf/local.conf}

\centerline{\$ sudo vi build/conf/local.conf}

\bigskip
Nota: en lugar de vi, se pueden usar nano o incluso gedit. Estos son editores de texto ordenados por complejidad.

\bigskip
En este punto hay que tener cuidado debido a que existen muchas variables a editar y se necesita mucho conocimiento para poder cambiarlas.


La mínima cantidad de variables a editar para un desarrollo correcto son las siguientes:

\bigskip
BBFILES = “/stuff/openembedded/recipes/*/*.bb”

MACHINE = “beagleboard”

DISTRO = “angstrom-2008.1”

PARALLEL\_MAKE = “-j 5”

INHERIT += “rm\_work”

\bigskip
Nota: Los parámetros detallados antes ya existen en el archivo de configuración, algunos deben ser descomentados y/o editados ya que lo único que cambia es el valor asignado.

\bigskip
BBFILES: indica que archivos son considerados durante el desarrollo.

\bigskip
MACHINE: el nombre asociado a la SBC que se esté usando. Para saber el nombre asociado a la SBC se puede ver el contenido del directorio

\leftline{/stuff/openembedded/conf/machine.}

\bigskip
DISTRO: qué versión de la distribución se quiere instalar. Aquí se eligió la última versión estable de Angström, aunque si se pone “angstrom-2010.x”, se obtiene una versión más nueva (no asegura estabilidad). La versión no solo afecta a la distribución sino que la versión del kernel generado va a depender de esta versión. Por ejemplo, con 2008.1 se obtiene un kernel 2.6.32 y con 2010.x se obtiene un kernel 2.6.37. Para saber cuales son las versiones disponibles al momento se puede ver el contenido del directorio 
/stuff/openembedded/conf/distro.

\bigskip
PARALLEL\_MAKE: indica cuantas operaciones simultáneas puede realizar el procesador de la pc de desarrollo. En general el valor se puede calcular como sigue: (cantidad de procesadores)x2 +1. En este caso 5 equivale a una cpu del tipo core2duo.

\bigskip
INHERIT += “rm\_work”: esta opción elimina los fuentes después de haber construido los paquetes. Esto hace que el tamaño del desarrollo en disco, no supere los 10GB. Si esta opción no se elige, se deben tener por lo menos 40GB de espacio libre en disco duro. También se puede decir que si se elige esta opción algunos fuentes deberán ser bajados nuevamente en cada desarrollo, lo que lo puede hacer más lento.


\bigskip
Conviene leer todo el archivo para tener una idea básica de lo que hace. Si en algún lugar se quiere hacer referencia al “home” del usuario, la ruta se debe escribir completa (no se puede $\sim$).

La última línea debe ser borrada (esto es para asegurarse de que se leyó todo). 

\bigskip
\leftline{Ejecución:}

\bigskip
Siempre antes de empezar a desarrollar se debe ejecutar lo siguiente:

\bigskip
\centerline{\$ export BBPATH=/stuff/build:/stuff/openembedded}

\centerline{\$ export PATH=/stuff/bitbake/bin:\$PATH}

\bigskip
Comenzando el desarrollo:

\bigskip
\centerline{\$ cd /stuff/build}

\centerline{\$ bitbake console-image}

\bigskip
Nota: Al ejecutarlo por primera vez, demora varias horas. 

\bigskip
Si aparecen errores como “Please set persistent and cache” o “no se puede acceder al directorio tmp” esto se soluciona dando permisos al directorio stuff:

\bigskip
\centerline{\$ sudo su}

\centerline{\$ chmod -R 777 /stuff}

\bigskip
El comando bitbake console-image baja todos los fuentes y genera todos los binarios necesarios para la ejecución de la  distribución Angström en modo consola. Otra opción, si solo queremos un kernel, es el comando bitbake virtual/kernel, pero para entender bien el funcionamiento del bitbake, la primera vez se recomienda bitbake console-image.

\bigskip
Luego de ejecutado el comando, se crea toda la estructura de directorios.

\bigskip
A continuación se detallan los más importantes:

\bigskip
/stuff/build/tmp/deploy/glibc/images/beagleboard/ 

Aquí se guardan los archivos generados.

\bigskip
/stuff/build/tmp/work/beagleboard-angstrom-linux-gnueabi/

Aquí se encuentran los directorios con los fuentes del kernel y el u-boot.

\section{uImage}\label{anx_sw_uIm}

Se detallan las modificaciones en el archivo board\_omap3beagle.c necesarios para la inicialización correcta de las interfaces SPI y GPIO. Como ya se comentó este archivo está ubicado en /stuff/build/tmp/work/beagleboard-angstrom-linux-gnueabi/linux-omap-.../git/arch/arm/mach-omap2/ y es el encargado de toda la inicialización de las interfaces del sistema.

\bigskip
En el caso de la interfaz SPI se vio que no se lograba un mapeo de la interfaz en /dev, lo que no permitía el acceso a ésta a nivel de usuario. En el caso de la interfaz GPIO se vio que para los pines GPIO no basta con los cambios realizados en el u-boot para establecer su dirección y valor al iniciar el sistema.
A continuación se plantea una posible solución para ambos casos.

\bigskip
\leftline{Cambios asociados al SPI:}

\bigskip
Se creó una estructura (spi\_board\_info beagle\_mcspi\_board\_info) que contempla todas las posibilidades de interfaz SPI en la Beagleboard y agrega información sobre éstas.
En la estrucutra se pueden ver tres formas de representar al SPI: spi3.0, spi3.1 y spi4.0. El microprocesador de la Beagleboard tiene 4 interfaces SPI disponibles de las cuales la 3 y la 4 son accesibles desde el bloque de expansión de la Beagleboard. Además la interfaz spi3 se puede encontrar en dos modalidades 3.0 o 3.1 dependiendo de si se utiliza el CS0 o el CS1 como chip select de la interfaz. La interfaz spi4 solo puede utilizar el CS0.
Es por esto que en la estructura se definen spi3.0, spi3.1 y spi4.0.
Dentro de cada interfaz definida se agrega información sobre la interfaz, como ser el nombre (modalias), la máxima velocidad de transferencia/recepción de datos (max\_speed\_hz), número de bus (bus\_num), chip select (chip\_select) y modo del spi (SPI\_MODE\_1).

\begin{verbatim}
static struct spi_board_info beagle_mcspi_board_info[] = { 
    /* spi 3.0 */ 
    { 
        .modalias	= "spidev", 
        .max_speed_hz	= 48000000, /* 48 Mbps */ 
        .bus_num	= 3, 
        .chip_select	= 0,	 
        .mode = SPI_MODE_1, 
    }, 
    /* spi 3.1 */ 
    { 
        .modalias	= "spidev", 
        .max_speed_hz	= 48000000, /* 48 Mbps */ 
        .bus_num	= 3, 
        .chip_select	= 1,	 
        .mode = SPI_MODE_1, 
    }, 
    /* spi 4.0 */ 
    { 
        .modalias	= "spidev", 
        .max_speed_hz	= 48000000, /* 48 Mbps */ 
        .bus_num	= 4, 
        .chip_select	= 0,	 
        .mode = SPI_MODE_1, 
    }, 
 }; 
\end{verbatim}

Luego de definidas las interfaces fue creada una función (omap3\_beagle\_init\_spi\_rf2) que las inicializara.

\begin{verbatim}
static void __init omap3_beagle_init_spi_rf2(void) 
{ 
    printk(KERN_INFO "Usando SPI\n");  
    /* hook the spi ports to the spidev driver */ 
    spi_register_board_info(beagle_mcspi_board_info, 
    ARRAY_SIZE(beagle_mcspi_board_info)); 
}
\end{verbatim}

Para que la función de inicialización de la interfaz SPI pueda ejecutarse, se debe hacer referencia a ésta en la función general de inicialización de interfaces asociada a la Beagleboard (omap3\_beagle\_init).

\begin{verbatim}
omap3_beagle_init_spi_rf2();
\end{verbatim}

Con estos cambios se logró que las interfaces SPI sean accesibles en el espacio de usuario bajo /dev y mapeadas como spidev3.0, spidev3.1, spidev4.0.

\newpage
\leftline{Cambios asociados al GPIO:}

\bigskip
Se creó una función (gpio\_config\_rf2) que dado un número asociado con el pin GPIO, establece su dirección y valor.

\begin{verbatim}
static void gpio_config_rf2(unsigned gpio, int direction, 
int value) {
  /* Tell the kernel, we want to use the GPIO*/
  if (gpio_request(gpio, "gpio\n") != 0) {
    printk(KERN_ALERT "Unable to request GPIO %d\n", 
    gpio);
  }
  else {
    /* Now tell the kernel that GPIO is an (in-out)put 
    and should be set to value (only as output) */
    switch (direction) {
      case 0: if (gpio_direction_output(gpio, value) != 0) {
                printk(KERN_ALERT "Unable to set GPIO 
                direction for GPIO %d\n", gpio);
              }
              else {
                /* enable direction on userspace */
                if (gpio_export(gpio, 1) != 0){ 
                  printk(KERN_ALERT "Unable to set GPIO 
                  export for GPIO %d\n", gpio);
                }
              }
              break;
      case 1: if (gpio_direction_input(gpio) != 0) {
                printk(KERN_ALERT "Unable to set GPIO 
                direction for GPIO %d\n", gpio);
              }
              else {
                /* enable direction on userspace */
                if (gpio_export(gpio, 1) != 0) { 
                  printk(KERN_ALERT "Unable to set GPIO 
                  export for GPIO %d\n", gpio);
                }
              }
              break;
      default: break;
    }
  }	
}
\end{verbatim}

Se creó la función de inicialización (gpio\_rf2) que establece la configuración de todos los pines GPIO del sistema RF$^{2}$.

\begin{verbatim}
static void __init gpio_rf2(void)
{
    printk(KERN_ALERT "Configurando GPIO RF2...\n");
    gpio_config_rf2(133, 0, 1); /*E*/
    gpio_config_rf2(134, 0, 0); /*D5*/
    gpio_config_rf2(136, 0, 0); /*D7*/
    gpio_config_rf2(137, 0, 0); /*XOE*/
    gpio_config_rf2(138, 0, 0); /*led rojo*/
    gpio_config_rf2(139, 0, 0); /*led_verde*/
    gpio_config_rf2(144, 0, 0); /*RST_SC*/
    gpio_config_rf2(145, 0, 0); /*led_amarillo*/
    gpio_config_rf2(156, 0, 0); /*RW*/
    gpio_config_rf2(157, 0, 0); /*RS*/
    gpio_config_rf2(158, 0, 0); /*Buzzer*/
    gpio_config_rf2(159, 0, 0); /*D4*/
    gpio_config_rf2(161, 0, 0); /*D6*/
    gpio_config_rf2(162, 0, 0); /*Backlight*/
    gpio_config_rf2(168, 0, 1); /*RST_RF*/
    gpio_config_rf2(183, 1, 0); /*IRQ_RF*/
}
\end{verbatim}

Luego, como en el caso de la interfaz SPI, se debe hacer referencia a la función anterior en la función de inicialización del sistema (omap3\_beagle\_init).

\begin{verbatim}
gpio_rf2();
\end{verbatim}

Con estos cambios se logró una cambio en la configuración de los pines GPIO, según la dirección y el valor que les corresponde para el buen funcionamiento del sistema RF$^{2}$.


\section{Instalación y configuración de librfid-tool}\label{ins_conf_librfid}

A continiuación se detalla la instalación y configuración de librfid para su uso con OpenPCD y con el lector/escritor RFID diseñado.

Para comenzar se descarga la biblioteca:

\bigskip
\centerline{\$ svn checkout https://svn.gnumonks.org/trunk/librfid/}

\bigskip
Dentro del directorio raíz, se encuentran una serie de directorios con los fuentes. Los más importantes se detallan a continuación:

\bigskip
utils: en este directorio de encuentran las funciones asociadas con la herramienta librfid-tool. Se destaca librfid-tool.c donde se encuentra la función main de la aplicación librfid-tool.

\bigskip
src: en este directorio se encuentran todos los fuentes de la biblioteca librfid.

\bigskip
include: en este directorio se encuentran todos los encabezados de las funciones de la biblioteca librfid.


\bigskip
\leftline{OpenPCD}

\bigskip
Para comenzar se intentó la comunicación desde el PC para luego pasar a la Beagleboard, ya que existe mucha documentación para el primer caso [REF]. En los dos casos fue necesario compilar la biblioteca para utilizar en la arquitectura elegida.

\bigskip
OpenPCD en PC:

\bigskip
Como primer paso, se conecta el OpenPCD al PC. Para saber si el dispositivo es detectado por la PC, es necesario lo siguiente:

\bigskip
\centerline{\$ lsusb}

\bigskip
Aquí debe aparecer (entre otros dispositivos conectados) un dispositivo con un identificador ID 16c0:076b (vendor:product). 

\bigskip
Nota: En caso de que este dispositivo no aparezca, se debe usar un HUB con alimentación externa.

\bigskip
Compilando librfid:

\bigskip
Para compilar la biblioteca son necesarios los siguientes paquetes: libtool, libusb-dev, libcurl-dev (libcurl4gnutls-dev instalado en este caso).

\bigskip
Se debe ir hasta el directorio donde se encuentra la biblioteca descargada (librfid por ejemplo) y escribir lo siguiente:

\bigskip
\centerline{\$ cd librfid}

\centerline{\$ ./configure}

\centerline{\$ make}

\centerline{\$ sudo make install}


\bigskip
OpenPCD en la Beagleboard:

\bigskip
Antes que nada se debe conectar el OpenPCD a la Beagleboard y verificar que es detectado al igual que en la instalación en el PC:

\bigskip
\centerline{\$ lsusb}

\bigskip
Se tuvo que utilizar un HUB con alimentación externa ya que la Beagleboard no logró ver al OpenPCD.

\bigskip
La compilación se realiza directamente en la Beagleboard.

\bigskip
Al igual que en el caso de la compilación para el uso en un PC, se debieron obtener los paquetes libtool, libusb-dev, libcurl-dev. Para instalar los paquetes se utilizó el siguiente comando:

\bigskip
\centerline{\$ opkg install “paquete”}
 
\bigskip
Se copia la biblioteca (sin compilar) a la Beagleboard y luego:

\bigskip
\centerline{\$ cd librfid}

\centerline{\$ ./configure}

\centerline{\$ make}

\centerline{\$ make install}


\bigskip
Lector-escritor RFID en la Beagleboard:

\bigskip
El lector/escritor RFID se conecta a la Beagleboard a través de una interfaz SPI.
Para habilitar las funcionalidades de la librfid asociadas con la comunicación SPI, es necesario indicar al configurar, que se quiere utilizar esta interfaz a través de la opción $--$enable-spidev. La compilación se realiza en la Beagleboard:

\bigskip
\centerline{\$ cd librfid}

\centerline{\$ ./configure $--$enable-spidev}

\centerline{\$ make}

\centerline{\$ make install}

\bigskip
Con esto se logró compilar la librfid con opciones para utilizar la interfaz SPI


\section{Depuración remota}\label{GDB}

A continuación se detalla la configuración de depuración remota con conexión ethernet.

\bigskip
En la Beagleboard:    

\bigskip                							
\centerline{\$ gdbserver localhost: $<$puerto$>$ $<$ejecutable Aplicación$>$ $<$argumentos$>$}

\bigskip
En el pc de desarrollo:

\bigskip
\centerline{\$ gdb}

\centerline{\$ target remote $<$ip\_Beagleboard$>$:$<$puerto$>$}

\bigskip
$<$puerto$>$: número del puerto por el que se conectan. El puerto no debe estar ocupado por otra aplicación. Por ejemplo un número $>$ 2000 funciona correctamente.

\bigskip
$<$ejecutable Aplicación$>$ $<$argumentos$>$: es el nombre de la aplicación que se quiere depurar y si la aplicación necesita algún argumento para ejecutarse correctamente también se deben agregar.

\bigskip
$<$ip\_Beagleboard$>$: es la ip de la Beagleboard.


\section{Formateo y particionado de la memoria SD}\label{sd_format}

Se van a necesitar dos particiones, una FAT32 de más de 32MB y una ext3 (el resto del espacio), la
primer partición (FAT32) debe ser booteable.
Hay dos maneras de hacerlo, una es usando el GParted (modo gráfico) y la otra es por consola.

\subsection{Formateo utilizando GParted}

Se instala el GParted:

\centerline{\$ sudo apt-get install gparted}

Se crean las particiones y se les da formato.
Se da click derecho sobre la partición FAT32, gestionar opciones y se marca boot. también se puede dar un nombre a cada partición.


\subsection{Formateo manual de la memoria SD}

El siguiente procedimiento se realiza por consola.

\bigskip
Antes que nada se debe saber dónde está la SD (memory card).
Para saberlo se ejecuta en consola: 

\centerline{\$ dmesg}

\bigskip
Se obtiene en parte lo siguiente: 
\begin{verbatim}
sd 3:0:0:0: Attached scsi generic sg1 type 0 
sd 3:0:0:0: [sdb] 7729152 512-byte logical blocks: 
(3.95 GB/3.68 GiB) 
sd 3:0:0:0: [sdb] Write Protect is off 
sd 3:0:0:0: [sdb] Mode Sense: 03 00 00 00 
sd 3:0:0:0: [sdb] Assuming drive cache: write through 
sd 3:0:0:0: [sdb] Assuming drive cache: write through 
sdb: sdb1 
sd 3:0:0:0: [sdb] Assuming drive cache: write through 
sd 3:0:0:0: [sdb] Attached SCSI removable disk 
\end{verbatim}

En este caso la SD está en /dev/sdb 

\bigskip
Se borran las particiones: 

\centerline{\$ sudo fdisk /dev/sdb}

\bigskip
\begin{verbatim}
Command (m for help): o 
Building a new DOS disklabel. Changes will remain in 
memory only, until you decide to write them. After 
that, of course, the previous content won't be 
recoverable. 
Warning: invalid flag 0x0000 of partition table 4 
will be corrected by w(rite) 
\end{verbatim}

Información de la memoria: 

\begin{verbatim}
Command (m for help): p 
Disk /dev/sdb: 3957 MB, 3957325824 bytes 
.... 
\end{verbatim}

Recordar la cantidad de bytes.

\bigskip
Se entra en Expert mode: 

\bigskip
\begin{verbatim}
Command (m for help): x 
\end{verbatim}

Se quiere setear la geometría de la siguiente forma: 255 heads, 63 sectors, y se calcula el 
número de cilindros requeridos por la tarjeta: 

\bigskip
C=trunk(B/255/63/512), donde C:cilindros, B:número de bytes de la tarjeta (anotado previamente) 
En este caso: C=trunk(481,117)=481 

\begin{verbatim}
Expert command (m for help): h 
Number of heads (1-256, default 4): 255 
Expert command (m for help): s 
Number of sectors (1-63, default 62): 63 
Warning: setting sector offset for DOS compatiblity 
Expert command (m for help): c 
Number of cylinders (1-1048576, default 1011): 481 
\end{verbatim}


Se va a crear la partición FAT32 y a marcarla como booteable: 

\begin{verbatim}
Expert command (m for help): r 
Command (m for help): n 
Command action 
e extended 
p primary partition (1-4) 
p 
Partition number (1-4): 1 
First cylinder (1-481, default 1): (Enter) 
Using default value 1 
Last cylinder or +size or +sizeM or +sizeK (1-481, 
default 481): +50 
//son como 400MB 
Command (m for help): t 
Selected partition 1 
Hex code (type L to list codes): c 
Changed system type of partition 1 to c (W95 FAT32 
(LBA)) 
Command (m for help): a 
Partition number (1-4): 1 
\end{verbatim}

Se crea la segunda partición: 

\begin{verbatim}
Command (m for help): n 
Command action 
e extended 
p primary partition (1-4) 
p 
Partition number (1-4): 2 
First cylinder (52-481, default 52): (Enter) 
Using default value 52 
Last cylinder or +size or +sizeM or +sizeK (52-481, 
default 481):(Enter) 
Using default value 481 
\end{verbatim}

Se imprime para ver como va todo: 

\begin{verbatim}
Command (m for help): p 
Disk /dev/sdb: 3957 MB, 3957325824 bytes 
255 heads, 63 sectors/track, 481 cylinders 
Units = cylinders of 16065 * 512 = 8225280 bytes 
Device Boot 
/dev/sdb1 * 
Start 
1 
End 
Blocks Id System 
51 
409626 c W95 FAT32 (LBA) 
/dev/sdb2 
52 
481 
3453975 83 Linux 
Command (m for help): w 
The partition table has been altered! 
Calling ioctl() to re-read partition table. 
WARNING: Re-reading the partition table failed with 
error 16: Device or resource busy. The kernel still uses 
the old table. The new table will be used at the next reboot. 
WARNING: If you have created or modified any DOS 6.x 
partitions, please see the fdisk manual page for 
additional information. 
Syncing disks. 
\end{verbatim}

Se desmontan las particiones creadas: 

\bigskip
\centerline{\$ umount /dev/sdb1}

\centerline{\$ umount /dev/sdb2}

\bigskip
Puede que diga que ya no está montado, en ese caso se sigue igualmente. 

\bigskip
Luego hay que formatear las particiones: 

\bigskip
\centerline{\$ sudo mkfs.msdos -F 32 /dev/sdb1 -n nombre}

\begin{verbatim}
mkfs.msdos 3.0.7 (24 Dec 2009) 
\end{verbatim}

\centerline{\$ sudo mkfs.ext3 /dev/sdb2 -L otroNombre}
\begin{verbatim}
mke2fs 1.41.11 (14-Mar-2010) 
Filesystem label= 
OS type: Linux 
Block size=4096 (log=2) 
Fragment size=4096 (log=2) 
216000 inodes, 863493 blocks 
43174 blocks (5.00%) reserved for the super user 
First data block=0 
Maximum filesystem blocks=402653184 
27 block groups 
32768 blocks per group, 32768 fragments per group 
8000 inodes per group 
Superblock backups stored on blocks: 
32768, 98304, 163840, 229376, 294912, 819200 
Writing inode tables: done 
Creating journal (16384 blocks): done 
Writing superblocks and filesystem accounting information: done
\end{verbatim}

\bigskip
Si dice que no encuentra el dispositivo, se saca la SD y se vuelve a colocar.

\section{Instalación de PCSC-Lite, CCID y pcsc-tools, y agregado de lector serial}\label{anx_pcsc_inst}

A continuación se describe el proceso de instalación en la Beagleboard, el procedimiento para un PC común es el mismo.

\bigskip
Primero se bajan los fuentes asociados a la PCSC-Lite \cite{pcsc/ccid_down}, CCID \cite{pcsc/ccid_down} y pcsc-tools \cite{pcsctools_down}. Luego se envían a la Beagleboard.

\bigskip
Paquetes necesarios en la Beagleboard: libusb-1.0-dev.

\bigskip
\centerline{\$ opkg install libusb-1.0-dev}

\bigskip
PCSC-Lite:

\bigskip
Para la instalación de la PCSC-Lite se usó la biblioteca libusb, aunque se puede hacer con el uso de la biblioteca libudev.
Se supone que los fuentes se encuentran en el directorio pcsclite.

\centerline{\$ cd pcsclite}

\$ ./configure $--$disable-libudev LIBUSB\_CFLAGS=-I/usr/include/libusb-1.0 LIBUSB\_LIBS="-L/usr/lib -lusb-1.0" $--$enable-ipcdir=/var/run/pcscd $--$enable-usbdropdir=/usr/drivers $--$enable-confdir=/etc/reader.conf.d $--$prefix=/usr

\bigskip
LIBUDEV\_CFLAGS: Dirección donde se encuentran los .h asociados con libusb.

LIBUDEV\_LIBS: Dirección donde está libusb.

$--$enable-ipcdir: Dirección donde se guardan archivos relacionados con la comunicación con el demonio de la pcsclite (pcscd).

$--$enable-usbdropdir: Dirección donde se guardan drivers usb (asociado con la instalación del ccid).

$--$enable-confdir: Dirección donde se guardan archivos relacionados con la configuración serial.

$--$prefix:  Dirección a partir de la cual se instalan los archivos necesarios para el correcto funcionamiento de la biblioteca.

\bigskip
\centerline{\$ make}

\centerline{\$ make install}

\bigskip
CCID:

\bigskip
Se supone que los fuentes se encuentran en el directorio ccid.

\bigskip
\centerline{\$ cd ccid}

\$ ./configure LIBUSB\_CFLAGS=-I/usr/include/libusb-1.0 LIBUSB\_LIBS="-L/usr/lib -lusb-1.0" PCSC\_CFLAGS=-I/usr/include/PCSC/ PCSC\_LIBS="-L/usr/lib -lpcsclite" $--$enable-usbdropdir=/usr/drivers $--$prefix=/usr

\centerline{\$ make}

\centerline{\$ make install}

\bigskip
PCSC-TOOLS:

\bigskip
Se supone que los fuentes se encuentran en el directorio pcsc-tools.

\bigskip
\centerline{\$ make}

\centerline{\$ make install}

\bigskip
\bigskip
Pasos para agregar el lector de tarjetas serial, en la biblioteca pcsclite:

\bigskip
Se crea el directorio para drivers de lectores (es posible que ya haya sido creado por CCID al ser instalado). 

\bigskip
\centerline{\$ mkdir /usr/drivers/}

Dentro de este directorio se ubica la biblioteca dinámica del driver para el lector de tarjetas. 

\bigskip	 
\centerline{\$ scp rf2\_sc.so root@172.16.1.14:/usr/drivers}

\bigskip
Luego es necesario crear el archivo de configuración donde se encuentran los parámetros del lector serial. Es posible conocer el directorio donde debe ubicarse el archivo de configuración ejecutando el comando: 

\bigskip
\centerline{\$ pcscd -v}

\bigskip
Se crea el archivo: 

\bigskip
\$ mkdir /etc/reader.conf.d/ 

\$ touch /etc/reader.conf.d/reader.conf 

\bigskip
Se edita el archivo reader.conf agregando las siguientes líneas: 

\begin{verbatim}
##########################################
# Configuration file for pcsc-lite 
# Reader Proyecto-RF2 FING-UDELAR 

FRIENDLYNAME  rf2_sc 
DEVICENAME    /dev/ttyS1 
LIBPATH       /usr/drivers/rf2_sc.so 
CHANNELID     1 
##########################################
\end{verbatim}

CHANNELID indica el número de puerto donde se encuentra el dispositivo: 

\begin{verbatim}
1 ---> /dev/pcsc/1 
2 ---> /dev/pcsc/2 
3 ---> /dev/pcsc/3 
\end{verbatim}

El puerto serial se encuentra realmente en /dev/ttySi, por tanto se debe realizar un enlace simbólico /dev/pcsc/i ---$>$ /dev/ttySi . Para efectuar lo anterior se crea el directorio pcsc bajo dev: 

\bigskip
\centerline{\$ mkdir /dev/pcsc}

\centerline{\$ cd /dev/pcsc}

\centerline{\$ ln -s /dev/ttySi i}

donde i es el número de puerto serial que eusado por el lector de tarjetas. 

\bigskip
Se reinicia el demonio pcscd y se ejecuta la herramienta pcsc\_scan para que muestre el dispositivo: 

\begin{verbatim}
...	
Scanning present readers... 
0: rf2_sc 00 00 

... 
Reader 0: rf2_sc 00 00 
\end{verbatim}


\section{Pruebas sobre las interfaces}

\section{led.c}\label{anx_sw_led}

\begin{verbatim}
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
FILE *fp;

int main(int argc, char** argv)
{
  printf("\n**********************************\n"
  "* Welcome to PIN Blink program *\n"
  "* ....blinking pin 13 on expansion port *\n"
  "* ....rate of 1 Hz............ *\n"
  "**********************************\n");
  //create a variable to store whether we are 
  //sending a '1' or a '0'
  char set_value[4];
  //Integer to keep track of whether we want on or off
  int toggle = 0;
  //Using sysfs we need to write "134" 
  //to /sys/class/gpio/export
  //This will create the folder /sys/class/gpio/gpio134
  if ((fp = fopen("/sys/class/gpio/export", "ab")) == NULL)
  {
    printf("Cannot open export file.\n");
    exit(1);
  }
  //Set pointer to begining of the file
  rewind(fp);
  //Write our value of "134" to the file
  strcpy(set_value,"134");
  fwrite(&set_value, sizeof(char), 3, fp);
  fclose(fp);
  printf("...export file accessed, new pin now accessible\n");
  //SET DIRECTION
  //Open the LED's sysfs file in binary for 
  //reading and writing, store file pointer in fp
  if ((fp = fopen("/sys/class/gpio/gpio134/direction", "rb+")) 
  == NULL)
  {
    printf("Cannot open direction file.\n");
    exit(1);
  }
  //Set pointer to begining of the file
  rewind(fp);
  //Write our value of "out" to the file
  strcpy(set_value,"out");
  fwrite(&set_value, sizeof(char), 3, fp);
  fclose(fp);
  printf("...direction set to output\n");
  //SET VALUE
  //Open the LED's sysfs file in binary for 
  //reading and writing, store file pointer in fp
  if ((fp = fopen("/sys/class/gpio/gpio134/value", "rb+")) 
  == NULL)
  {
    printf("Cannot open value file.\n");
    exit(1);
  }
  //Set pointer to begining of the file
  rewind(fp);
  //Write our value of "1" to the file
  strcpy(set_value,"1");
  fwrite(&set_value, sizeof(char), 1, fp);
  fclose(fp);
  printf("...value set to 1...\n");
  //Run an infinite loop - will require 
  //Ctrl-C to exit this program
  while(1)
  {
    //Set it so we know the starting value 
    //in case something above doesn't leave it as 1
    strcpy(set_value,"1");
    if ((fp = fopen("/sys/class/gpio/gpio134/value", "rb+")) 
    == NULL)
    {
      printf("Cannot open value file.\n");
      exit(1);
    }
    toggle = !toggle;
    if(toggle)
    {
      //Set pointer to begining of the file
      rewind(fp);
      //Write our value of "1" to the file
      strcpy(set_value,"1");
      fwrite(&set_value, sizeof(char), 1, fp);
      fclose(fp);
      printf("...value set to 1...\n");
    }
    else
    {
      //Set pointer to begining of the file
      rewind(fp);
      //Write our value of "0" to the file
      strcpy(set_value,"0");
      fwrite(&set_value, sizeof(char), 1, fp);
      fclose(fp);
      printf("...value set to 0...\n");
    }
    //Pause for one second
    sleep(1);
  }
  return 0;
}
\end{verbatim}



\section{uart.c}\label{anx_sw_uart}

\begin{verbatim}
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <termios.h>
#include <stdio.h>

#define BAUDRATE B9600
#define SERIALPORT "/dev/ttyS1"
#define _POSIX_SOURCE 1 /* POSIX compliant source */
#define FALSE 0
#define TRUE 1
#define BUFFWRITE 10
#define BUFFREAD 255

int fd; //descriptor del archivo asociado con tty
struct termios oldtio,newtio;

//inicialización
int tty_init (void)
{
  //abrimos el puerto ttyS1
  fd = open(SERIALPORT, O_RDWR | O_NOCTTY ); 
  if(fd<0)
  return 0; //hubo errores
  else
  {
    printf("Puerto %s, abierto. fd: %d\n", SERIALPORT, fd);
    /* save current port settings */
    tcgetattr(fd,&oldtio); 
    //bzero(&newtio, sizeof(newtio));
    newtio.c_cflag = BAUDRATE | CS8 | CLOCAL | CREAD;
    newtio.c_iflag = IGNPAR;
    newtio.c_oflag = 0;
    /* set input mode (non-canonical, no echo,...) */
    newtio.c_lflag = 0;
    /* inter-character timer unused */
    newtio.c_cc[VTIME] = 0;
    /* bloqueo la lectura hasta que llegue 1 caracter */ 
    newtio.c_cc[VMIN] = 1; 
    tcflush(fd, TCIFLUSH);
    tcsetattr(fd,TCSANOW,&newtio);
    return 1; //no hubo errores
  }
}

//envio de un caracter por UART
void escribir (char s[10])
{
  write(fd, s, BUFFWRITE); //escribe el string en UART-Tx
  printf("dato enviado: %s\n", s);
}

//lectura de caracter por UART
char leer (void)
{
  char r[BUFFREAD];
  if(read(fd, r, BUFFREAD) == -1)
  return 0; //No hay datos o se incluyen ceros
  else
  return r[0]; //no hubo errores, se retorna el valor leido
}

int main (void)
{
  //cantidad de caracteres leidos por UART
  int UART_get_return; 
  //indica si se pudo abrir el puerto o no
  int UART_init_return; 
  char buff[BUFFREAD];
  //inicializacion de la UART
  UART_init_return = tty_init(); 
  
  //no se pudo abrir el puerto
  if (UART_init_return == 0) 
  printf("no se pudo abrir el puerto ttyS1.\n");
  else //se pudo abrir el puerto
  {
    char str[10]={'a','s','d','f','g','h','j','k','l','t'};
    escribir(str);
    UART_get_return = read(fd,buff,BUFFREAD);
    
    // 0 = no se encontraron datos en Rx
    if (UART_get_return == 0) 
    printf("no hay datos para leer\n");
    else //1 = dato encontrado
    {
      buff[UART_get_return]=0;
      printf("dato leido: %s:%d\n", buff,UART_get_return);
    }
  }
  tcsetattr(fd,TCSANOW,&oldtio);
}

\end{verbatim}
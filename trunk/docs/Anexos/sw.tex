\chapter{Software}

\section{OpenEmbedded-Bitbake}

Para la instalación, configuración y ejecución de esta herramienta, se deben seguir los pasos en detalle. Se debe tener una buena conexión a internet para la descarga de fuentes, espacio libre en disco duro de no menos de 10GB, buen procesador y paciencia ya que los desarrollos completos demoran varias horas.

\bigskip
Primero se instalan los paquetes previos necesarios. 

\bigskip
Paquetes importantes:

\bigskip
\centerline{\$ sudo apt-get install sed wget cvs subversion git-core $\backslash$}

\centerline{coreutils unzip texi2html texinfo docbook-utils $\backslash$}

\centerline{gawk python-pysqlite2 diffstat help2man make gcc build-essential g++ $\backslash$}

\centerline{desktop-file-utils chrpath}

\bigskip
Paquetes secundarios (aceleran los procesos):

\bigskip
\centerline{\$ sudo apt-get install libxml2-utils xmlto python-psyco apr}

\newpage
Chequear que /bin/sh no tiene un enlace simbólico a “dash”:

\bigskip
\centerline{\$ ls -l /bin/sh}

\bigskip
Debe estar enlazado a “bash”. Si no lo está:

\bigskip
\centerline{\$ sudo dpkg-reconfigure dash}

\bigskip
Aquí seleccionamos NO instalar “dash” como /bin/sh

\bigskip
Compilador para aumentar la velocidad de bitbake:

\bigskip
\centerline{\$ sudo apt-get install python-psyco}

\bigskip
Para versiones de Ubuntu mayores o iguales a la 10.04:

\bigskip
\centerline{\$ sudo su}

\centerline{\$ echo 128 $>$ /proc/sys/vm/mmap\_min\_addr}

\centerline{\$ exit}

\centerline{\$ sudo sysctl -w vm.mmap\_min\_addr=128}


\leftline{Instalación:}

\bigskip
El directorio base seleccionado para el desarrollo con OpenEmbedded es stuff (puede ser otro), y se ubicó en /.

\bigskip
Se crea la estructura de directorios:

\bigskip
\centerline{\$ sudo mkdir -p /stuff/build/conf}

\centerline{\$ cd /stuff/}

\bigskip
Bitbake es la herramienta de construcción que utiliza OpenEmbedded. Está escrita en Python, por lo que no es necesario compilarlo para que funcione.

\bigskip
\centerline{\$ sudo wget http://download.berlios.de/bitbake/bitbake-1.10.2.tar.gz}

\bigskip
Nota: esta es la última versión disponible al momento. Para saber cual es la última versión disponible, entrar a: http://download.berlios.de/bitbake/.

Para las nuevas versiones es necesario tener instalado Python 2.6 o posterior.

\newpage
Luego se descomprime el tar.gz bajado:

\bigskip
\centerline{\$ sudo tar -xzf bitbake-1.10.2.tar.gz}

\centerline{\$ ls}

\bigskip
Se debe ver un directorio llamado en este caso bitbake-1.10.2 (se puede renombrar a: “bitbake” por comodidad).

\bigskip
Para obtener OpenEmbedded es necesario tener instalado git.

\bigskip
Ahora se hace lo siguiente:

\bigskip
\centerline{\$ cd /stuff}

\centerline{\$ sudo git clone git://git.openembedded.org/openembedded}

\bigskip
Nota: git clone es para hacer un checkout del repositorio. 

Otro repositorio es http://repo.or.cz/r/openembedded.git

\bigskip
Demora mucho. Al finalizar se crea un directorio con el nombre openembedded.

\bigskip
Se recomienda actualizar OpenEmbedded una vez al día:

\bigskip
\centerline{\$ cd /stuff/openembedded}

\centerline{\$ sudo git pull}

\bigskip
\leftline{Configuración:}

\bigskip
Se modifica la configuración local, donde se debe indicar todo lo que se quiera crear.

\bigskip
\centerline{\$ cd /stuff/}

\centerline{\$ sudo cp openembedded/conf/local.conf.sample build/conf/local.conf}

\centerline{\$ sudo vi build/conf/local.conf}

\bigskip
Nota: en lugar de vi, se pueden usar nano o incluso gedit. Estos son editores de texto ordenados por complejidad.

\bigskip
En este punto hay que tener cuidado debido a que existen muchas variables a editar y se necesita mucho conocimiento para poder cambiarlas.


La mínima cantidad de variables a editar para un desarrollo correcto son las siguientes:

\bigskip
BBFILES = “/stuff/openembedded/recipes/*/*.bb”

MACHINE = “beagleboard”

DISTRO = “angstrom-2008.1”

PARALLEL\_MAKE = “-j 5”

INHERIT += “rm\_work”

\bigskip
Nota: Los parámetros detallados antes ya existen en el archivo de configuración, algunos deben ser descomentados y/o editados ya que lo único que cambia es el valor asignado.

\bigskip
BBFILES: indica que archivos son considerados durante el desarrollo.

\bigskip
MACHINE: el nombre asociado a la SBC que se esté usando. Para saber el nombre asociado a la SBC se puede ver el contenido del directorio

\leftline{/stuff/openembedded/conf/machine.}

\bigskip
DISTRO: qué versión de la distribución se quiere instalar. Aquí se eligió la última versión estable de Angström, aunque si se pone “angstrom-2010.x”, se obtiene una versión más nueva (no asegura estabilidad). La versión no solo afecta a la distribución sino que la versión del kernel generado va a depender de esta versión. Por ejemplo, con 2008.1 se obtiene un kernel 2.6.32 y con 2010.x se obtiene un kernel 2.6.37. Para saber cuales son las versiones disponibles al momento se puede ver el contenido del directorio 
/stuff/openembedded/conf/distro.

\bigskip
PARALLEL\_MAKE: indica cuantas operaciones simultáneas puede realizar el procesador de la pc de desarrollo. En general el valor se puede calcular como sigue: (cantidad de procesadores)x2 +1. En este caso 5 equivale a una cpu del tipo core2duo.

\bigskip
INHERIT += “rm\_work”: esta opción elimina los fuentes después de haber construido los paquetes. Esto hace que el tamaño del desarrollo en disco, no supere los 10GB. Si esta opción no se elige, se deben tener por lo menos 40GB de espacio libre en disco duro. También se puede decir que si se elige esta opción algunos fuentes deberán ser bajados nuevamente en cada desarrollo, lo que lo puede hacer más lento.


\bigskip
Conviene leer todo el archivo para tener una idea básica de lo que hace. Si en algún lugar se quiere hacer referencia al “home” del usuario, la ruta se debe escribir completa (no se puede $\sim$).

La última línea debe ser borrada (esto es para asegurarse de que se leyó todo). 

\bigskip
\leftline{Ejecución:}

\bigskip
Siempre antes de empezar a desarrollar se debe ejecutar lo siguiente:

\bigskip
\centerline{\$ export BBPATH=/stuff/build:/stuff/openembedded}

\centerline{\$ export PATH=/stuff/bitbake/bin:\$PATH}

\bigskip
Comenzando el desarrollo:

\bigskip
\centerline{\$ cd /stuff/build}

\centerline{\$ bitbake console-image}

\bigskip
Nota: Al ejecutarlo por primera vez, demora varias horas. 

\bigskip
Si aparecen errores como “Please set persistent and cache” o “no se puede acceder al directorio tmp” esto se soluciona dando permisos al directorio stuff:

\bigskip
\centerline{\$ sudo su}

\centerline{\$ chmod -R 777 /stuff}

\bigskip
El comando bitbake console-image baja todos los fuentes y genera todos los binarios necesarios para la ejecución de la  distribución Angström en modo consola. Otra opción, si solo queremos un kernel, es el comando bitbake virtual/kernel, pero para entender bien el funcionamiento del bitbake, la primera vez se recomienda bitbake console-image.

\bigskip
Luego de ejecutado el comando, se crea toda la estructura de directorios.

\bigskip
A continuación se detallan los más importantes:

\bigskip
/stuff/build/tmp/deploy/glibc/images/beagleboard/ 

Aquí se guardan los archivos generados.

\bigskip
/stuff/build/tmp/work/beagleboard-angstrom-linux-gnueabi/

Aquí se encuentran los directorios con los fuentes del kernel y el u-boot.

\section{uImage}

Se detallan las modificaciones en el archivo board\_omap3beagle.c necesarios para la inicialización correcta de las interfaces SPI y GPIO. Como ya se comentó este archivo está ubicado en /stuff/build/tmp/work/beagleboard-angstrom-linux-gnueabi/linux-omap-.../git/arch/arm/mach-omap2/ y es el encargado de toda la inicialización de las interfaces del sistema.

\bigskip
En el caso de la interfaz SPI se vio que no se lograba un mapeo de la interfaz en /dev, lo que no permitía el acceso a ésta a nivel de usuario. En el caso de la interfaz GPIO se vio que para los pines GPIO no basta con los cambios realizados en el u-boot para establecer su dirección y valor al iniciar el sistema.
A continuación se plantea una posible solución para ambos casos.

\bigskip
\leftline{Cambios asociados al SPI:}

\bigskip
Se creó una estructura (spi\_board\_info beagle\_mcspi\_board\_info) que contempla todas las posibilidades de interfaz SPI en la Beagleboard y agrega información sobre éstas.
En la estrucutra se pueden ver tres formas de representar al SPI: spi3.0, spi3.1 y spi4.0. El microprocesador de la Beagleboard tiene 4 interfaces SPI disponibles de las cuales la 3 y la 4 son accesibles desde el bloque de expansión de la Beagleboard. Además la interfaz spi3 se puede encontrar en dos modalidades 3.0 o 3.1 dependiendo de si se utiliza el CS0 o el CS1 como chip select de la interfaz. La interfaz spi4 solo puede utilizar el CS0.
Es por esto que en la estructura se definen spi3.0, spi3.1 y spi4.0.
Dentro de cada interfaz definida se agrega información sobre la interfaz, como ser el nombre (modalias), la máxima velocidad de transferencia/recepción de datos (max\_speed\_hz), número de bus (bus\_num), chip select (chip\_select) y modo del spi (SPI\_MODE\_1).

\begin{verbatim}
static struct spi_board_info beagle_mcspi_board_info[] = { 
    /* spi 3.0 */ 
    { 
        .modalias	= "spidev", 
        .max_speed_hz	= 48000000, /* 48 Mbps */ 
        .bus_num	= 3, 
        .chip_select	= 0,	 
        .mode = SPI_MODE_1, 
    }, 
    /* spi 3.1 */ 
    { 
        .modalias	= "spidev", 
        .max_speed_hz	= 48000000, /* 48 Mbps */ 
        .bus_num	= 3, 
        .chip_select	= 1,	 
        .mode = SPI_MODE_1, 
    }, 
    /* spi 4.0 */ 
    { 
        .modalias	= "spidev", 
        .max_speed_hz	= 48000000, /* 48 Mbps */ 
        .bus_num	= 4, 
        .chip_select	= 0,	 
        .mode = SPI_MODE_1, 
    }, 
 }; 
\end{verbatim}

Luego de definidas las interfaces fue creada una función (omap3\_beagle\_init\_spi\_rf2) que las inicializara.

\begin{verbatim}
static void __init omap3_beagle_init_spi_rf2(void) 
{ 
    printk(KERN_INFO "Usando SPI\n");  
    /* hook the spi ports to the spidev driver */ 
    spi_register_board_info(beagle_mcspi_board_info, 
    ARRAY_SIZE(beagle_mcspi_board_info)); 
}
\end{verbatim}

Para que la función de inicialización de la interfaz SPI pueda ejecutarse, se debe hacer referencia a ésta en la función general de inicialización de interfaces asociada a la Beagleboard (omap3\_beagle\_init).

\begin{verbatim}
omap3_beagle_init_spi_rf2();
\end{verbatim}

Con estos cambios se logró que las interfaces SPI sean accesibles en el espacio de usuario bajo /dev y mapeadas como spidev3.0, spidev3.1, spidev4.0.

\newpage
\leftline{Cambios asociados al GPIO:}

\bigskip
Se creó una función (gpio\_config\_rf2) que dado un número asociado con el pin GPIO, establece su dirección y valor.

\begin{verbatim}
static void gpio_config_rf2(unsigned gpio, int direction, 
int value) {
  /* Tell the kernel, we want to use the GPIO*/
  if (gpio_request(gpio, "gpio\n") != 0) {
    printk(KERN_ALERT "Unable to request GPIO %d\n", 
    gpio);
  }
  else {
    /* Now tell the kernel that GPIO is an (in-out)put 
    and should be set to value (only as output) */
    switch (direction) {
      case 0: if (gpio_direction_output(gpio, value) != 0) {
                printk(KERN_ALERT "Unable to set GPIO 
                direction for GPIO %d\n", gpio);
              }
              else {
                /* enable direction on userspace */
                if (gpio_export(gpio, 1) != 0){ 
                  printk(KERN_ALERT "Unable to set GPIO 
                  export for GPIO %d\n", gpio);
                }
              }
              break;
      case 1: if (gpio_direction_input(gpio) != 0) {
                printk(KERN_ALERT "Unable to set GPIO 
                direction for GPIO %d\n", gpio);
              }
              else {
                /* enable direction on userspace */
                if (gpio_export(gpio, 1) != 0) { 
                  printk(KERN_ALERT "Unable to set GPIO 
                  export for GPIO %d\n", gpio);
                }
              }
              break;
      default: break;
    }
  }	
}
\end{verbatim}

Se creó la función de inicialización (gpio\_rf2) que establece la configuración de todos los pines GPIO del sistema $RF^{2}$.

\begin{verbatim}
static void __init gpio_rf2(void)
{
    printk(KERN_ALERT "Configurando GPIO RF2...\n");
    gpio_config_rf2(133, 0, 1); /*E*/
    gpio_config_rf2(134, 0, 0); /*D5*/
    gpio_config_rf2(136, 0, 0); /*D7*/
    gpio_config_rf2(137, 0, 0); /*XOE*/
    gpio_config_rf2(138, 0, 0); /*led rojo*/
    gpio_config_rf2(139, 0, 0); /*led_verde*/
    gpio_config_rf2(144, 0, 0); /*RST_SC*/
    gpio_config_rf2(145, 0, 0); /*led_amarillo*/
    gpio_config_rf2(156, 0, 0); /*RW*/
    gpio_config_rf2(157, 0, 0); /*RS*/
    gpio_config_rf2(158, 0, 0); /*Buzzer*/
    gpio_config_rf2(159, 0, 0); /*D4*/
    gpio_config_rf2(161, 0, 0); /*D6*/
    gpio_config_rf2(162, 0, 0); /*Backlight*/
    gpio_config_rf2(168, 0, 1); /*RST_RF*/
    gpio_config_rf2(183, 1, 0); /*IRQ_RF*/
}
\end{verbatim}

Luego, como en el caso de la interfaz SPI, se debe hacer referencia a la función anterior en la función de inicialización del sistema (omap3\_beagle\_init).

\begin{verbatim}
gpio_rf2();
\end{verbatim}

Con estos cambios se logró una cambio en la configuración de los pines GPIO, según la dirección y el valor que les corresponde para el buen funcionamiento del sistema $RF^{2}$.


\section{Depuración remota}

A continuación se detalla la configuración de depuración remota con conexión ethernet.

\bigskip
En la Beagleboard:    

\bigskip                							
\centerline{\$ gdbserver localhost: $<$puerto$>$ $<$ejecutable Aplicación$>$ $<$argumentos$>$}

\bigskip
En el pc de desarrollo:

\bigskip
\centerline{\$ gdb}

\centerline{\$ target remote $<$ip\_Beagleboard$>$:$<$puerto$>$}

\bigskip
$<$puerto$>$: número del puerto por el que se conectan. El puerto no debe estar ocupado por otra aplicación. Por ejemplo un número $>$ 2000 funciona correctamente.

\bigskip
$<$ejecutable Aplicación$>$ $<$argumentos$>$: es el nombre de la aplicación que se quiere depurar y si la aplicación necesita algún argumento para ejecutarse correctamente también se deben agregar.

\bigskip
$<$ip\_Beagleboard$>$: es la ip de la Beagleboard.
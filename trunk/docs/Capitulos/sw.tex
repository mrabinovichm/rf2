%capítulo 6
\chapter{Software}

%sección 6.1
\section{Introducción}
Se debe destacar que todo el desarrollo de software se basó exclusivamente en herramientas de software libre. La distribución GNU/Linux elegida para el sistema embebido se llama Angström \cite{Angs}. Esta distribución es muy usada en aplicaciones que utilizan una Beagleboard y cuenta con una gran cantidad de bibliotecas implementadas en lenguaje C, que permiten gran escalabilidad a la hora de incorporar nuevos periféricos en la aplicación.

%sección 6.2
\section{Arquitectura de Software}
%sección 6.2.1
\subsection{Descripción}
Un sistema GNU/Linux se compone de diferentes partes que interactúan entre sí, formando capas ordenadas con distintos grados de abstracción respecto al hardware. Ésto se puede apreciar en la figura \ref{Fig:SisLinux} donde se muestra a grandes rasgos el sistema. 

\begin{figure}[H]
\centering
  \begin{center}
  \includegraphics[scale=.4]{Imagenes/SisLinux.jpg} 
  \end{center}
  \caption{Sistema GNU/Linux}\label{Fig:SisLinux} 
\end{figure}

El bootloader es la aplicación ejecutada al inicio del sistema. Su función es inicializar el hardware, y cargar el kernel en memoria RAM para su ejecución. En general el bootloader se divide en dos etapas, la primera etapa es fuertemente dependiente
del CPU con que cuenta la placa, y su función es buscar en particiones activas para luego cargar 
en memoria RAM la segunda etapa del bootloader. Esta segunda etapa se encarga de descomprimir
en memoria RAM la imagen comprimida del kernel, para luego ser ejecutado y que éste tome el
control del sistema.
El kernel se encarga a grandes rasgos de habilitar interrupciones, configurar la memoria, y montar un sistema de archivos virtual que permite a su vez cargar los módulos necesarios para la interfaz con periféricos. Luego se monta el sistema de archivos asociado a la distribución (fileSystem). En este nuevo sistema de archivos es donde se instalarán diferentes programas y bibliotecas para la correcta ejecución de aplicaciones.
En funcionamiento, toda la comunicación con periféricos se realiza a través del kernel que es la parte más cercana al hardware.
Cada vez que se ejecuta una aplicación, ésta hace uso de llamadas al sistema (syscalls) para poder comunicarse con el kernel, y éste se encarga de la comunicación con los periféricos.


Una referencia interesante para entender el proceso de arranque es \cite{linuxBoot}.


%sección 6.2.2
\subsection{Sistema Operativo}
En el arranque, la Beagleboard tiene la posibilidad de buscar el bootloader y el kernel en NAND, o en dispositivos extraíbles tales como memorias USB o memorias SD. Para el sistema RF$^{2}$, se eligió un arranque a través de una memoria SD ya que es fácil de manipular.

En la figura \ref{Fig:SD} se puede ver como queda distribuida la memoria SD con las distintas partes
que conforman el sistema operativo. 

\begin{figure}[H]
\centering
  \begin{center}
  \includegraphics[scale=.4]{Imagenes/sd.jpg} 
  \end{center}
  \caption{Memoria SD para funcionar en Beagleboard}\label{Fig:SD} 
\end{figure}

En la memoria SD se pueden distinguir dos particiones, una en formato FAT32 y otra
en formato ext3. La partición en FAT32 es llamada “de arranque”, y es donde se encuentra 
el bootloader (MLO, u-boot.bin) y la imagen comprimida del kernel (uImage). 
La partición en ext3 es donde se encuentra el sistema de archivos (fileSystem).

El MLO es el equivalente al bootloader de la primera etapa, en general ya viene precargado en la memoria NAND de la Beagleboard. Es posible generarlo, o incluso bajar una versión ya compilada desde la web de Angström \cite{Angs}. Como característica principal tiene la capacidad de buscar el u-boot.bin en dispositivos extraíbles como memorias SD o USB.

El u-boot.bin es equivalente al bootloader de la segunda etapa. En el sistema RF$^{2}$ fue necesario generarlo, ya que tiene la posibilidad de configurar el bloque de expansión de la Beagleboard.

El uImage es el kernel del sistema. Fue necesario generarlo, ya que se debieron modificar sus fuentes para que queden habilitadas las interfaces de comunicación con los dispositivos periféricos.

El fileSystem (también conocido como RootFileSystem) es el correspondiente a una distribución GNU/Linux llamada Angström. Se pueden llegar a precargar distintos programas y bibliotecas dependiendo de la forma en que se genere.
Angström es una distribución GNU/Linux diseñada específicamente para sistemas embebidos desarrollados
para SBCs como la usada para este prototipo. Ésto lo hace más eficiente que otros sistemas operativos para la aplicación desarrollada. La elección de esta distribución se debió a que es de los más recomendados y utilizados en la documentación y foros de Beagleboard \cite{foroBb}.


%sección 6.3
\section{Herramientas utilizadas en el desarrollo del sistema}

%sección 6.3.1
\subsection{Introducción}
Para el desarrollo de sistemas existe una gran variedad de herramientas útiles, algunas de software libre y otras privativas. El hecho de tener tantas opciones disponibles, a pesar de ser una ventaja, a veces dificulta la elección de las herramientas correctas.

Para la elección de las herramientas se tomó como primer criterio de decisión el hecho que sean libres, así como las experiencias de otras personas que ya han transitado caminos comunes, consultando y participando en foros activos.

\bigskip
Cabe señalar que en el PC de desarrollo se utilizó Ubuntu 10.10.

\bigskip
A continuación se detallan las herramientas utilizadas para el desarrollo del sistema. 

%sección 6.3.2
\subsection{MLO, u-boot.bin y uImage}
No fue necesario generar el MLO debido a su simpleza, puesto que el binario precompilado realiza bien su función.

El u-boot.bin y el uImage fueron generados con la herramienta de desarrollo y compilación OpenEmbedded-Bitbake \cite{OE-Bb} que es una fusión de dos herramientas: OpenEmbedded, herramienta para construcción y mantenimiento de distribuciones, y \\
Bitbake, herramienta de compilación similar al Make \cite{Make} que automatiza la construcción de ejecutables entre otros. Esto es, OpenEmbedded utiliza Bitbake para su objetivo. OpenEmbedded-Bitbake es una herramienta muy potente y difícil de aprender al principio. Luego de entendido su principio de funcionamiento se hace muy simple su uso, para lo que es necesario tener acceso a una buena conexión a internet debido a que realiza descargas de paquetes en forma habitual.
Con esta herramienta también se pueden generar el MLO y el fileSystem, aunque se prefirió utilizar otras herramientas por sobre ésta. 
Su instalación, configuración, estructura y uso se pueden ver en el apéndice \ref{anx_sw_oe}.

%sección 6.3.3
\subsection{FileSystem}
Para la generación del fileSystem de Angström, se utilizó la herramienta web \\
Narcissus \cite{Narc} disponible en la página de Angström.
Esta herramienta permite seleccionar entre diferentes dispositivos (entre los cuales está Beagleboard), los programas que se quieran instalar, el formato de la imágen seleccionada, e incluso se puede generar un kit de desarrollo (SDK) para el PC de desarrollo. Debido a la facildad de uso y a los buenos resultados obtenidos, se decidió utilizar esta opción por sobre la del fileSystem generado por la herramienta OpenEmbedded-Bitbake.

%sección 6.3.4
\subsection{Crosscompilación}
Se llama crosscompilar al proceso de compilación en una arquitectura, generando binarios para su ejecución una arquitectura diferente. En el caso del proyecto RF$^{2}$, se compilan paquetes en una arquitectura x86 (PC de desarrollo) para ser utilizados en una arquitectura ARM.


Para la crosscompilación se utilizó el SDK generado por Narcissus y la herramienta Make para generar los archivos necesarios. La instalación, configuración y uso del SDK se encuentran en el apéndice \ref{anx_sw_SDK}.

%sección 6.3.5
\subsection{Depuración de código}
Para la depuración, se utilizó la herramienta GDB del proyecto GNU. 
Al momento de compilar, es necesario agregar la opción -g para que la aplicación pueda ser depurada. Esta opción agrega información en el código de la aplicación.
La interfaz del GDB es por consola, aunque existen algunos programas que utilizan GDB y además ofrecen una interfaz gráfica (DDD \cite{DDD}). \\
Algunos de los comandos útiles y sus usos más comunes pueden encontrarse en el apéndice \ref{depurar}.


\bigskip
Sin olvidar el hecho que la aplicación RF$^{2}$ está diseñada para una arquitectura distinta a la del PC de desarrollo, para el depurado de la aplicación existen dos alternativas. 

La primera opción es lo que se podría llamar depuración local, esto es, instalar GDB en la Beagleboard y depurar la aplicación en ésta. Para saber lo que sucede es necesario acceder de forma remota a la Beagleboard desde el PC de desarrollo. 

La segunda opción es la depuración remota. La depuración remota consiste en realizar la depuración de la aplicación desde el PC de desarrollo. Para esto, es necesario instalar GDBServer en la Beagleboard y tener instalado el GDB específico de la Beagleboard en el PC de desarrollo. Luego se establece una conexión, serial o ethernet, entre la Beagleboard y el PC de desarrollo. Por más detalles sobre la configuración referirse al apéndice \ref{GDB}.

\bigskip
La primera opción no es posible para sistemas embebidos chicos en los cuales no se puede instalar GDB, aunque éste no es el caso de la Beagleboard. 
Se tienen más y mejores herramientas en el PC de desarrollo, por ejemplo programas con interfaz gráfica que ayudan a entender mejor lo que está pasando. Por algunas de estas razones, se prefiere el uso de la depuración remota. 

\bigskip
Se utilizaron indistintamente tanto la primera opción como la segunda.

%sección 6.3.6
\subsection{Bibliotecas}

\begin{itemize}
\item pcsc-scan es una herramienta de uso por línea de comandos, que una vez ejecutado imprime el nombre del lector PC/SC conectado y en caso que exista una tarjeta de contacto insertada imprime también su ATR. Luego  escanea el lector constantemente e indica si se retira o inserta una tarjeta. Esta aplicación fue utilizada para testear el lector de tarjetas de contacto.
\item  librfid-tool es una herramienta de uso por línea de comandos que da acceso de bajo nivel RFID utilizando los lectores soportados por la biblioteca para manejo de lectores/escritores RFID, librfid. Esta herramienta fue utilizada para testear lectores/escritores de tarjetas RFID.
\end{itemize}

A continuación se detallan la forma de llamar a la aplicación y algunas de las opciones soportadas. Para la instalación y uso referirse al apéndice \ref{ins_conf_librfid}

%sección 6.3.7
\subsection{Otras herramientas}
subversion \cite{subversion} y Git \cite{git}, para control de versiones. 

Geany \cite{geany} para edición y compilación de código.

minicom \cite{minicom} para comunicación serial.

strace es un comando Linux que lista las llamadas al sistema, útil para la depuración.

%sección 6.4
\section{Desarrollo}

%sección 6.4.1
\subsection{MLO}
Como se mencionó anteriormente, no fue necesario generar el MLO debido a que la Beagleboard viene con uno pre-instalado, y en caso que no funcione en forma correcta se puede descargar desde un repositorio de Angström \cite{Angs_MLO}. No fue necesario realizar ningún cambio en el archivo ya que realiza su función correctamente.

%sección 6.4.2
\subsection{Multiplexado de pines}
El microprocesador OMAP3530 tiene muchos pines con distintas interfaces entre las
que se cuentan puertos UART, SPI, GPIO, etc., pero no todos son accecibles desde la Beagleboard. 
Para poder acceder a algunos de estos puertos del microprocesador, existe en la placa de la
Beagleboard un bloque de expansión de 28 pines.

\bigskip
Por defecto, en el bloque de expansión no se encuentran las señales que se quieren. Esto 
lleva a que se tenga que modificar el estado inicial de los pines. 
Existen dos formas de modificar los pines de modo de tener las señales que se precisan. Una de ellas es modificar el bootloader y la otra es modificar el kernel. Esto implica cambios en los archivos fuentes y posterior compilación que genere los nuevos binarios u-boot o uImage. 

\bigskip
Para la modificación de las señales disponibles en el bloque de expansión se decidió modificar el u-boot, ya que la modificación por u-boot es más intuitiva y por experiencia se sabe que lo que más se actualiza y/o modifica es el kernel. 

%sección 6.4.3
\subsection{u-boot}
Como se mencionó anteriormente en el u-boot se realizó la configuración de los pines del bloque de expansión de la Beagleboard. 
Cada pin del bloque de expansión tiene varias funcionalidades asociadas, y la configuración de la 
funcionalidad depende de un multiplexado modificable a nivel de software. Esto es, dependiendo del “modo de pin” elegido, la función que se obtiene en dicho pin.
Para que los cambios hechos en el u-boot tengan el efecto esperado al arrancar el sistema, es necesario que en la configuración del kernel esté la opción CONFIG\_OMAP\_MUX=no, lo que imposibilita al kernel a realizar este mismo cambio. Esta opción no está activada por defecto para versiones de kernel 2.6.32 y posteriores. 

\bigskip
Antes que pueda ser modificado el estado de los pines del bloque de expansión,
es necesario obtener los archivos fuente con los cuales se genera el archivo binario u-boot.

En el apéndice \ref{anx_sw_ub} se encuentran los pasos a seguir para generar el archivo binario u-boot.bin.

\bigskip
El archivo generado se encuentra en /stuff/build/tmp/deploy/glibc/images/beagleboard/ aunque con su nombre seguido de un número identificatorio, el cual debe ser borrado para poder mantener el nombre necesario (u-boot.bin).

\bigskip
Pese a que en la literatura y foros, se plantea lo contrario, no fue posible establecer los atributos “valor” y “dirección” de los pines GPIO mediante la modificación planteada (una posible solución puede verse en el apéndice \ref{anx_sw_uIm}). Lo que sí cambia efectivamente es el modo del pin, permitiendo obtener las interfaces adecuadas en el bloque de expansión.

%sección 6.4.4
\subsection{uImage}
La versión del kernel elegida fue la 2.6.32 ya que en el momento que se comenzó el desarrollo era la versión más estable. Aunque también se hicieron pruebas con las versiones 2.6.29 y 2.6.37.\\
Durante el arranque del sistema, el kernel carga los módulos y controladores necesarios para el funcionamiento del 
hardware que forma parte del sistema embebido. También se montan las interfaces para poder interactuar con los distintos dispositivos a ser conectados a la Beagleboard como lo son: SPI, GPIO, UART, etc.. Las interfaces SPI y UART se encuentran bajo el directorio /dev en el sistema de archivos, y GPIO bajo el directorio /sys/class/gpio. En algunos casos, en /dev no aparecen algunas de las interfaces configuradas, lo que lleva a modificar los fuentes del kernel para que esto así suceda. Este fue el caso de la interfaz SPI que no quedó mapeada en /dev pese a que había sido configurada en los fuentes del u-boot. También hubo problemas con los atributos “valor” y “dirección” de los GPIO, como se mencionó anteriormente. Adicionalmente hacía falta un módulo para simular una conexión ethernet sobre una interfaz USB para establecer una conexión entre la Beagleboard y un PC, que emula una tarjeta de red por software.
Todo esto llevó a que se tuvieran que modificar los archivos fuente del kernel.

Para ver los pasos a seguir para modificar y generar el uImage, referirse al apéndice \ref{ker}.

%sección 6.4.5
\subsection{FileSystem}

Como se mencionó anteriormente, el fileSystem se generó a partir de la herramienta web Narcissus.\\
En el fileSystem es donde se encuentran los paquetes y programas ya instalados. Cuanto más programas se instalen más grande será en tamaño el fileSystem.

\bigskip
Para utilizar la herramienta Narcissus se debe acceder a la web de la herramienta \cite{Narc}.


\bigskip
Por detalles sobre como generar el fileSystem a partir de la herramienta Narcissus, referirse al apéndice \ref{narc}.


%sección 6.4.6
\subsection{Beagleboard}

\subsubsection{Preparación de la memoria SD}

Con los archivos MLO, u-boot.bin, uImage y fileSystem generados, se procede a la preparación de la memoria SD para correr por primera vez en la Beagleboard. En el apéndice \ref{sd_prep} se describen los pasos necesarios para el correcto funcionamiento del sistema.


\subsubsection{Configuración de los parámetros de arranque}

Existe una forma de saber lo que sucede en el arranque del sistema conectando la Beagleboard a un PC a través de un cable con conversor USB-SERIAL y utilizando la interfaz serial de la Beagleboard (/dev/ttyS2, inicializada por el bootloader) para la comunicación con el PC.

\bigskip
Para saber sobre la configuración en el PC para conexión serial con la Beagleboard ver apéndice \ref{serialBb}.

\bigskip
\leftline{Primer arranque de la Beagleboard}

\bigskip
Antes de arrancar se abre minicom por consola: 

\bigskip
\begin{verbatim}
$ minicom
\end{verbatim}

Se coloca la SD en la Beagleboard, se enchufa a la fuente de alimentación, y comienza el arranque del sistema. 

Para que el sistema arranque correctamente con los archivos generados previamente, se debe mantener presionado el botón “user” de la Beagleboard ya que en caso contrario en el arranque se busca el u-boot.bin primero en NAND, y si ya existe una versión preinstalada es ésta la que se va a cargar. Al apretar el botón “user” (no más de tres segundos) se logra un cambio en el orden de arranque, lo que hace que se cargue primero el u-boot.bin de la memoria SD.

Luego se debe ver una cuenta regresiva en pantalla. 
Si se apreta alguna tecla del teclado esta cuenta regresiva se detiene y se accede a la configuración de los parámetros de arranque del sistema (similar a una BIOS de un PC de escritorio). Para ver una lista de todas los parámetros del arranque, se debe ejecutar el comando printenv. En el apéndice \ref{printenv} puede verse el listado que devuelve la ejecución de dicho comando.

\bigskip
Entre los parámetros a modificar están los que indican como acceder a la SD (bootargs) y los comandos de arranque (bootcmd) donde se indica en que lugar encontrar el uImage. Para un arranque correcto a través de la SD, los valores de los parámetros anteriores deben ser los siguientes:

\begin{verbatim}
bootargs= 'console=ttyS2,115200n8 root=/dev/mmcblk0p2 
rw rootwait' 
bootcmd 'mmc init;fatload mmc 0 80300000 uImage;
bootm 80300000' 
\end{verbatim}

En general esto ya viene seteado correctamente. Si no es así, van a haber errores al arrancar el sistema. Una solución es setear los valores de estos atributos mediante el comando setenv:

\begin{verbatim}
OMAP3 beagleboard.org # setenv bootargs 'console=ttyS2,115200n8 
root=/dev/mmcblk0p2 rw rootwait' 

OMAP3 beagleboard.org # setenv bootcmd 'mmc init;fatload mmc 
0 80300000 uImage;bootm 80300000' 

OMAP3 beagleboard.org # saveenv 
\end{verbatim}

Nota: saveenv guarda los valores seteados en NAND.

\bigskip
También se puede modificar el tiempo de la cuenta regresiva (bootdelay) mencionada anteriormente para lograr un mejor tiempo de arranque.

\begin{verbatim}
OMAP3 beagleboard.org # setenv bootdelay 1

OMAP3 beagleboard.org # saveenv 
\end{verbatim}

Luego de aplicados los cambios en los parámetros de arranque, se reinicia el sistema.

\begin{verbatim}
OMAP3 beagleboard.org # reset 
\end{verbatim}

Un ejemplo de arranque del sistema puede verse en el apéndice \ref{arr}.

\subsubsection{Copia de MLO y u-boot.bin en NAND}

Recordando que se debe dejar apretado el botón “user” de la Beagleboard para lograr que se cargue el u-boot.bin de la memoria SD y no el de la NAND (por defecto), y dado que ésto no es conveniente para un sistema que pretende ser autónomo, se decidió copiar los archivos MLO y u-boot.bin a la memoria NAND. Esta operación es muy delicada y se deben seguir los pasos que se mencionan a continuación al pie de la letra, ya que cualquier error puede dejar inoperante a la Beagleboard (puede recuperarse según \cite{rec} y \cite{rec1}). Antes de hacerlo es conveniente tener la versión definitiva de los archivos a copiar ya que la NAND es una memoria delicada.

\bigskip
Para la copia de estos archivos a la memoria NAND referirse al apéndice \ref{copyNAND}.

\subsubsection{Beagleboard en la red}

Es de interés conectar la Beagleboard a través de una interfaz ethernet con el PC de desarrollo para poder intercambiar archivos e incluso conectar la Beagleboard a internet. Para lograr lo anterior se agregaron los módulos necesarios durante el desarrollo del uImage. Para la emulación de la conexión por red se utiliza el USB-OTG de la \\
Beagleboard.

\bigskip
\leftline{Conexión con beagle a través del USB-OTG}

\bigskip
Tener una conexión por red con la BeagleBoard permite el uso de comandos como ssh para acceso remoto y el envío de archivos mediante el comando scp. 
Si se conecta la Beagleboard con el PC de desarrollo, se puede ver en el PC la aparición de una conexión de red mediante la interfaz usb0. Se debe configurar esta interfaz como sigue:

\begin{verbatim}
$ ifconfig usb0 172.16.1.17 netmask 255.255.255.0
\end{verbatim}

La única condición que debe tener la ip es que no sea parte de la subred a la que pertenece el PC desarrollo (en general 192.168.x.x) ya que esto lleva a errores de comunicación y por ejemplo, no permite la salida de la Beagleboard a internet.

\bigskip
Para que se establezca la conexión es necesaria la ejecución de algunos comandos en la Beagleboard, por ejemplo interesa una ip fija para identificarla en la red. Para que la conexión se realice cada vez que se inicia el sistema, se creó un script (ethusb) que se corre al inicio y ejecuta los comandos antes mencionados.
A continuación se muestra el script ethusb:

\begin{verbatim}
#!/bin/sh 
echo Ya se puede conectar... 
ifconfig usb0 172.16.1.14 netmask 255.255.255.0 
route add default gw 172.16.1.17 
echo nameserver 192.168.1.2 > /etc/resolv.conf 
\end{verbatim}

Se configura la ip que va a tener la Beagleboard. La puerta de enlace debe ser la ip del PC de desarrollo y el nameserver debe ser la dirección de la ip de salida a internet que tiene la PC de desarrollo.

\bigskip
Para que el script se ejecute cada vez que arranca el sistema, se debe hacer lo siguiente:

\bigskip
\begin{verbatim}
$ cp ethusb /etc/init.d

$ cd /etc/rc5.d

$ ln -s ../init.d/ethusb S99ethusb
\end{verbatim}

Nota: El S99 quiere decir que lo que se ejecuta lo hace en el arranque, y que es el último en ejecutarse.

\bigskip
Ya no va a ser necesaria una configuración cada vez que se inicie el sistema. 
Hay que tener el USB desconectado durante el inicio del sistema, en caso contrario al arrancar se presenta un kernel panic.

Para la conexión de la Beagleboard a internet, ver apéndice \ref{BbInternet}. 

Para el uso del gestor de paquetes (opkg), ver apéndice \ref{opkg}. 


%seccion 6.4.7
\subsection{Bibliotecas}

\leftline{\bf{Software para el manejo de GPIO}}

Este módulo de software fue realizado desde cero, basándose en el fileSystem virtual SYSFS para el control de GPIOs \cite{gpio} \cite{gpioK}, esto permite que el código pueda ser portado a cualquier otro sistema que use GNU/Linux y que disponga de este tipo de hardware.

\bigskip
El módulo de software para el uso de los puertos de propósito general, GPIO, en principio puede resultar poco importante a simple vista, pero esta porción de código es usada por el resto de los módulos que conforman la aplicación completa del prototipo RF$^{2}$. 
Este módulo cuenta básicamente con una estructura que permite almacenar el estado de cada puerto, una macro, y cuatro funciones que se datallan a continuación.
La primera de las funciones se llama config\_gpio\_pin() y permite exportar desde el espacio kernel al espacio usuario las funcionalidades necesarias para hacer uso del puerto que se indica como argumento. Al momento en que se exporta, se indica la dirección, o sea si será un puerto de entrada o salida, a través de un parámetro que es pasado a la función.
La función que permite leer el valor actual de un puerto se llama read\_gpio\_pin(), es necesario pasarle como argumento el indicador del puerto del cual se quiere conocer su valor. El valor del puerto es guardado en la estructura que almacena el estado de cada puerto para posteriores consultas, sin tener que volver a llamar a dicha función.
Las últimas dos funciones son contrapuestas, set\_gpio\_pin() y clear\_gpio\_pin(), éstas permiten poner el valor de un puerto específico en el valor lógico “1” o “0” respectivamente. Previo a establecer o borrar el valor del puerto ambas funciones verifican que la dirección del mismo sea de salida (como mecanismo de seguridad no es posible cambiar el valor de un puerto de entrada).
Por su parte la macro reset\_status\_gpio() permite borrar el estado de un puerto que ya no esté en uso.


\bigskip
\leftline{\bf{Software para comunicación SAM}}

Hoy en día la mayoría de los lectores de tarjetas de contacto tienen una interfaz USB para ser conectado en un PC en aplicaciones de escritorio. Para el uso de este tipo de lectores sobre GNU/Linux, se hace uso de la especificación USB llamada CCID.
Sin embargo, las tarjetas de contacto no poseen un puerto USB sino un puerto serie para establecer la comunicación con algún dispositivo, es por esto que en la nueva generación de lectores siempre hay un  ASIC para lograr la interacción, por un lado con la tarjeta de contacto y por el otro la comunicación con el PC.
Como fue descrito en la sección de hardware, el lector de tarjetas de contacto tiene una interfaz serial pura para la transferencia de datos con las tarjetas. En base al diseño hardware elegido, las capas de software sobre las que se decidió trabajar son las que se detallan en la figura \ref{Fig:capas}. 

\begin{figure}[H]
\centering
  \begin{center}
  \includegraphics[scale=.4]{Imagenes/SW_sc1.jpg} 
  \end{center}
  \caption{Capas de software de trabajo}\label{Fig:capas} 
\end{figure}

\bigskip
En una primera etapa y para simplificar el desarrollo y la depuración del software, las capas empleadas fueron las que se muestran en la figura \ref{Fig:capas0}.


\begin{figure}[H]
\centering
  \begin{center}
  \includegraphics[scale=.4]{Imagenes/SW_sc2.jpg} 
  \end{center}
  \caption{Capas de software en una primera etapa}\label{Fig:capas0} 
\end{figure}

\bigskip
A continuación se describen las capas asociadas a la figura \ref{Fig:capas}.

\bigskip
\leftline{Controlador:}
El kernel es el encargado de manipular directamente los registros del puerto serial, las interrupciones que desde éste se generan y la ISR para atender las interrupciones.
La implementación del controlador del lector de tarjetas se basó en el controlador serial de GNU/Linux a través de su estructura “termios” \cite{termios}. Esta estructura permite configurar todos los parámetros necesarios para la comunicación serial como ser, baud rate, cantidad de bits por byte, bit de paridad, bit de parada entre otros. Las funciones read y write permiten la lectura y escritura de los bytes de datos que son recibidos y transmitidos por el puerto serial.

Dentro del proyecto MUSCLE/PCSCLite existe código ejemplo de controladores de lectores de tarjetas de contacto que son compatibles con la biblioteca, si bien el desarrollo se basó en alguno de ellos, como el hecho de usar el mismo nombre de funciones, su contenido fue desarrollado específicamente para controlar el hardware específico del prototipo RF$^{2}$.

\bigskip
\leftline{CT/API (Card Terminal / Application Programming Interface):}
Por encima del controlador serial se encuentra CT/API \cite{ctapi}, una interfaz definida por varias empresas (entre las que se incluye Telekom Alemania) en la década de los noventa, que permite encapsular el controlador específico de cada lector de tarjetas, de manera que la aplicación final no se vea afectada al cambiar un lector por otro.
Esta interfaz de programación está formada tan solo por tres funciones, CT\_init, CT\_data y CT\_close, que permiten la inicialización del lector, la transferencia de datos entre \\
host/lector o host/tarjeta (host se refiere a la SBC o PC donde se encuentra conectado el lector de tarjetas de contacto) directamente y el cierre de la comunicación.\\
CT\_init se encarga del pasaje de parámetros a la capa del controlador, para la configuración del puerto de comunicación entre el host y el lector de tarjetas. Los parámetros en uso aquí son: la tasa de transferencia de datos, el número de bits por cada byte, el tipo de paridad empleado y el puerto serie a ser utilizado.\\
CT\_data es la función encargada de transferir comandos y datos hacia y desde la tarjeta o hacia y desde el lector (en caso que el mismo esté formado por un ASIC o microprocesador). La manera de diferenciar desde donde es enviado el dato, es a través de un parámetro pasado a esta función, y de forma análoga se determina el destino del mensaje. El protocolo usado para la transferencia de datos es T=0, orientado a bytes y del cual pueden conocerse más detalles en \cite{SCHb}.\\
CT\_close es la contracara de  CT\_init, se encarga de cerrar la comunicación con el lector. Lo que hace básicamente es liberar el handle (puntero) asociado al puerto serial.

\newpage
Las funciones de apertura y cierre de la comunicación no necesitan ser modificadas, son similares en todos 
los controladores de lectores seriales compatibles con la biblioteca. Por otro lado la función CT\_data debió ser sustancialmente modificada para lograr el intercambio de datos a partir del protocolo T=0.

\bigskip
Para el caso en que los comandos y/o datos estén dirigidos hacia el lector, existe otra especificación, llamada CT/BCS \cite{ctbcs} (Card Terminal / Basic Command Set), donde se encuentran definidos una serie de comandos básicos para el manejo del lector. Estos comandos se nombran a continuación y se da una breve descripción.

\bigskip
RESET CT permite reiniciar el lector o tarjeta (en el caso de ser un lector mudo); de manera opcional puede devolver el ATR.

REQUEST ICC tiene como objeto devolver el ATR de la tarjeta una vez que la misma se encuentra ubicada en el zócalo del lector.

GET STATUS es empleado para conocer información sobre el lector o si la tarjeta está insertada y eléctricamente conectada en el lector. 

EJECT ICC genera la desactivación eléctrica de la tarjeta.

\bigskip
\leftline{IFDHandler:}
El siguiente componente en este stack de capas es ifdhandler \cite{ifdhandler}, no es otra cosa que un conjunto de funciones formando una API, empleada por pcsclite para encapsular el manejo del hardware de  lectores cuyos fabricantes quieran cumplir con las especificaciones PC/SC \cite{pcsclite_esp}. Una ventaja importante de esta API es que le permite a pcsclite operar tanto con lectores de puerto serial como con lectores de puerto USB.
Esta capa de software podría usarse directamente sobre el controlador del lector, prescindiendo de CT/API, aunque se decidió mantenerla por motivos de simplicidad ya que sólo es necesario sustituir la capa de aplicación por las restantes capas superiores como se indica en las figuras \ref{Fig:capas} y \ref{Fig:capas0}.

\bigskip
Las funciones que contiene esta capa de software fueron modificadas para que contengan a su vez las funciones de CT/API, y de esta manera hacer más fácil de integrar el controlador del lector con la biblioteca PCSCLite.

\bigskip
En lo que sigue se enumeran algunas de las funciones de esta API y se describen brevemente. Por más detalles ver el manual ifdhandler \cite{ifdhandler}.

\bigskip
IFDHCreateChannel establece el canal de comunicación con el lector. Para conseguirlo usa un parámetro llamado Channel, que indica cual es el puerto serial a usar, por ejemplo para el caso de GNU/Linux /dev/ttySx (x es el número que corresponda).

IFDHCloseChannel implementa la acción opuesta a la función anterior, cerrando el canal de comunicación con el lector de tarjetas.

IFDHGetCapabilities permite obtener las capacidades específicas del lector o de la tarjeta insertada en el mismo.

IFDHPowerICC se encarga del control de las señales de alimentación y reset que el lector suministra a la tarjeta. Desempeña tres acciones posibles, encendido, reset y apagado de la tarjeta.

IFDHTransmitToICC se encarga de la transferencia de datos con la tarjeta a través de alguno de los protocolos disponibles, como ser T=0 o T=1.

IFDHICCPresence retorna el estado de la tarjeta insertada en el zócalo del lector.

\bigskip
\leftline{PCSCLite:}
Por arriba de ifdhandler se encuentra la biblioteca pcsclite, ésta contiente todas las funciones necesarias para establecer la comunicación con un lector y la tarjeta conectada a éste último. Para el uso del controlador encapsulado por ifdhandler desde pcsclite es necesario seguir los pasos de configuración detallados en el apéndice \ref{anx_pcsc_inst}.

\bigskip
\leftline{Aplicación final:}
Por arriba de todas las capas descritas antes, se encuentra la aplicación del prototipo que hace uso de las funciones suministradas por pcsclite y donde se encuentran definidos los comandos APDU específicos con los que opera la tarjeta de contacto. Por razones de seguridad no se nos permite difundir la lista de comandos que son usados para la comunicación con el módulo SAM.


\bigskip
\leftline{\bf{Software RFID}}
librfid es una biblioteca de software libre para manejo de lectores/escritores RFID. Implementa el stack de protocolos del lado del dispositivo lector/escritor ISO 14443A, ISO 14443B, ISO 15693, Mifare Ultralight y Mifare Classic.

Entre los lectores soportados están, OpenPCD y algunos modelos Omnikey, éstos con interfaz de conexión USB. Además tiene soporte para cualquier otro lector con comunicación directa con el CL RC632 mediante la interfaz SPI y es por esta razón que se tuvo en cuenta.

El manejo de librfid es de bajo nivel y se comunica directamente con el kernel utilizando el módulo spidev. Librfid-tool implementa funciones de más alto nivel que hacen uso de las funciones de bajo nivel de la librfid. La estrucrura de software comentada se muestra en la figura \ref{sw_RFID}.

\begin{figure}[H]
\centering
  \begin{center}
  \includegraphics[scale=.4]{Imagenes/librfid-tool.jpg} 
  \end{center}
  \caption{Capa de software RFID}\label{sw_RFID} 
\end{figure}


A continuación se detallan los cambios introducidos en la biblioteca librfid para el correcto funcionamiento del lector/escritor RFID utilizando librfid-tool.

\bigskip
Se analizó el código principal de la aplicación librfid-tool y se vio que dentro del directorio utils en el archivo common.c se encuentra la función reader\_init la cual busca un lector/escritor entre los soportados. Esta función no tenía implementada una búsqueda para dispositivos conectados por SPI. Por lo tanto se tuvieron que agregar las siguientes líneas a la función para que el funcionamiento fuera posible:

\begin{verbatim}
rh = rfid_reader_open("/dev/spidev3.0", RFID_READER_SPIDEV);
if (!rh) {
    fprintf(stderr, "No SPIDEV found\n");
    return -1;
}
\end{verbatim}

Este cambio permitió detectar la interfaz SPI (spidev3.0). Algo a tener en cuenta, es que como en GNU/Linux las interfaces están asociadas a un archivo, el hecho de abrir el archivo no implica que haya nada conectado en esa interfaz. Por esta razón, la búsqueda de un lector/escritor conectado por interfaz SPI se realiza en última instancia.

\bigskip
Otro cambio fundamental es en la frecuencia de reloj del puerto SPI. Se incrementa a 10 MHz, ya que con la frecuencia establecida por defecto en la biblioteca librfid (1 MHz) el lector/escritor RFID no funciona correctamente. 

Toda la configuración de la comunicación por SPI se encuentra en rfid\_reader\_spidev.c que está en el directorio fuente src.

La función que se modificó es spidev\_open y el cambio se muestra a continuación:

\begin{verbatim}
tmp = 10e6; /* 10 MHz */
if (ioctl(spidev_fd, SPI_IOC_WR_MAX_SPEED_HZ, &tmp) < 0)
    goto out_rath;
\end{verbatim}

Se implementaron las funciones adecuadas para el manejo del pin RST\_RF, el cual puede encender y apagar el lector/escritor RFID diseñado.

\bigskip
Después de estudiadas las funciones que provee la herramienta librfid-tool, se estudió la posibilidad de su uso para la aplicación RF$^{2}$. 

Aunque sus funciones  son muy útiles, la gran mayoría no sirven completamente para la aplicación RF$^{2}$ debido a que fueron definidas para otros propósitos. 

Es de interés, que la herramienta librfid-tool siga manteniendo sus funcionalidades y pueda convivir con la aplicación RF$^{2}$, por lo que no se modificó el contenido de ninguna función de la herramienta. En el caso que alguna función fuera mayormente utilizable, se procedió a crear una nueva con los cambios necesarios.

Se implementaron la mayoría de las funciones, logrando compatibilidad con la biblioteca librfid. Entre las funciones creadas están las asociadas con la tarjeta RFID: autenticación según el tipo de clave, búsqueda de tarjetas próximas al lector, lectura y escritura de bloques de memoria, obtención del UID, etc.

\subsection{Aplicación final}

Para el desarrollo de la aplicación RF$^{2}$ se decidió trabajar sobre los fuentes de la herramienta librfid-tool, ya que maneja varias funciones de utilidad y es de ayuda a la hora de compilar para el armado de una aplicación completa. Se mantuvieron todas las opciones de la herramienta ya que son útiles, y pueden ayudar en un futuro para establecer orígenes de fallas. No se modificó ninguna función de la aplicación original y cuando fue necesaria alguna modificación, se procedió a implementar una nueva.

En la figura \ref{Fig:SW} se detallan las capas de software del sistema RF$^{2}$.

\begin{figure}[H]
\centering
  \begin{center}
  \includegraphics[scale=.35]{Imagenes/SW.jpg} 
  \end{center}
  \caption{Capas de software del sistema RF${^{2}}$}\label{Fig:SW} 
\end{figure}

\bigskip
Antes de seguir fue necesario entender el funcionamiento de las reglas de compilación creadas para la aplicación librfid-tool sobre librfid. En el directorio raíz, se encuentran los siguientes archivos importantes para el desarrollo del sistema: autogen.sh, configure.in, configure, Makefile.am, Makefile.flags.am, Makefile.in, Makefile.

\bigskip
Por detalles sobre la utilidad de cada uno de estos archivos, y su modificación para el funcionamiento de la aplicación RF$ ^{2} $ referirse al apéndice \ref{makefile}.

\bigskip
\leftline{\bf{Modificaciones en librfid-tool}}

Se implementó una función de inicialización, la cual inicializa todos los periféricos al arrancar la aplicación RF$^{2}$.

En librfid-tool.h se definieron constantes simbólicas para hacer configurable al sistema. Algunas de ellas son:

\bigskip
MONEDERO: lugar del arreglo “bloque” donde se encuentra el monedero.

SECTOR\_MONEDERO: sector donde se encuentra el monedero.

BLOQUE\_MONEDERO: bloque donde se encuentra el monedero.

BLOQUE\_RESPALDO: bloque donde se encuentra el respaldo del saldo.

TIEMPO\_BUZZER: tiempo de encendido del buzzer en $\mu$s.

PAUSA\_BUZZER: tiempo entre dos encendidas del buzzer en $\mu$s.

TIEMPO\_LED: tiempo de encendido del led en s.

INICIO: tiempo de espera al inicio en s. 

ESPERA: tiempo de espera estándar en s. 

FIN: tiempo de espera al final en s.


\bigskip
Se agregó una nueva opción (n) en el main de la aplicación librfid-tool que llama a la función principal(). Ésta, es la función principal de la aplicación RF$^{2}$, la cual se ejecuta en loop y se basa en el diagrama de flujo de la figura \ref{Fig:HW}. De este modo no se modifica el main original de librfid-tool (solo se agrega la opción n) y se dejan las opciones por defecto.
Se hizo uso de algunas funciones ya escritas y se crearon otras. En este punto no se modificó ninguna función de la aplicación original y cuando fue necesaria alguna modificación, se procedió a implementar una nueva función con las modificaciones previstas.
Luego viene la etapa de crosscompilación de la aplicación para ser probada en la SBC.

\bigskip
Por detalles sobre la crosscompilación de la aplicación final referirse al apéndice \ref{crosap}

\bigskip
\leftline{\bf{Funcionamiento general de la aplicación}}

Como se comentó antes, la programación se realizó de acuerdo al diagrama de flujo de la figura \ref{Fig:HW}.
Se desarrolló una estructura de directorios de forma que el sistema sea modular, esto es, cualquier cambio requerido en algún módulo del sistema, no afecta al resto.

\bigskip
Los mensajes al display, se realizan mediante la función dato\_lcd() la cual despliega el mensaje adecuado según una lista de mensajes guardados en mensajes.h, dentro del directorio lcd. Las funciones encender\_bl() y apagar\_bl() que se encuentran dentro del directorio lcd sirven para encender y apagar el backlight del display.
Las funciones relacionadas a los leds y el buzzer, se encuentran en el directorio gpio y el nombre del pin asociado con el led o buzzer a utilizar se encuentra en el archivo beagle\_gpio.h dentro del directorio gpio. Las funciones lb\_error(), lb\_consulta() y lb\_recarga(), realizan el encendido y apagado adecuado de los leds y buzzer de acuerdo a si se produce un error, consulta o recarga durante la transacción en curso.
 
\bigskip
Al iniciar la aplicación, se realiza la inicialización de los distintos módulos que conforman el sistema (interfaz de usuario y habilitación de comunicación con módulo\\
 lector/escritor RFID, pin RST\_RF). Ésto se realiza mediante la función inicio\_rf2(). Luego se abre el puerto de comunicación con el lector/escritor RFID. Con estos pasos finaliza la inicialización del sistema y se ingresa al loop principal de la aplicación.
Durante el transcurso de la transacción, se despliegan los mensajes adecuados a través de la interfaz de usuario.
Se realiza la búsqueda de una tarjeta mediante la utilización de la función busqueda\_tarjeta() que queda en loop esperando a que se encuentre una tarjeta en el campo del lector/escritor RFID.
Cuando se detecta una tarjeta, se inicia la comunicación con ésta mediante el uso de las funciones l2\_init() y l3\_init() (se inicia algoritmo de anticolisión y se establece el protocolo). Se previó el hecho que suceda algún error en estos pasos, volviendo a iniciar la comunicación.
Ya establecida la comunicación con la tarjeta, se obtiene el identificador de la tarjeta sin contacto (UID). Lo anterior se realiza mediante la función obtener\_uid(). En caso de presentarse un error, se comienza nuevamente el diálogo con la tarjeta. Cuando la tarjeta no pertenezca al grupo de tarjetas habilitadas para la aplicación, se ignora la presencia de la tarjeta inválida y no se despliegan mensajes al usuario.
Luego, se obtienen las claves asociadas con la tarjeta mediante el uso de la función claves\_mifare(). Esta función, le indica a la tarjeta de contacto que derive las claves de la tarjeta identificada con el UID obtenido en el paso anterior. Dado que es una función asociada con la tarjeta de contacto, ésta está definida en el archivo sam.c dentro del directorio sam.
Resta averiguar si la tarjeta tiene saldo a acreditar o no. Para ésto se utiliza la función consulta\_recarga(), la cual devuelve el monto a recargar a partir de la lectura del archivo local carga.txt. Para que el dispositivo no funcione en forma local la consulta de las opciones de recarga se hacen contra un servidor, como se indicó anteriormente esto no fue implementado por estar fuera del alcance de este proyecto.

A partir de aquí se diferencian dos casos, si la función anterior devuelve un valor mayor que cero entonces se está frente a una recarga, si devuelve cero, se está frente a una consulta. Si devolviera un valor negativo (por algún tipo de error) se realiza una consulta.

En el caso de consulta, se utiliza la función consulta, la cual con las claves adecuadas, lee el contenido de la memoria de la tarjeta asociado con el monto actual (Monedero) y despliega los mensajes adecuados mediante la interfaz de usuario.

En el caso de recarga, se hace uso de la función recarga, la cual con las claves adecuadas, lee el contenido de la memoria de la tarjeta asociado con el monto actual (Monedero), lo respalda (Respaldo), luego calcula el nuevo saldo, y escribe el nuevo saldo en el Monedero. Durante este proceso se despliegan los mensajes adecuados mediante la interfaz de usuario. Si la recarga se realizó correctamente, se debe borrar el saldo a acreditar obtenido mediante consulta\_recarga() (para no cargar dos veces el mismo saldo), para esto se utiliza la función reseteo\_recarga(). El borrado del saldo a acreditar se realiza siempre después que la tarjeta ya fue recargada, de este modo, se contempla el hecho que suceda un error al escribir el nuevo saldo a la tarjeta.

En ambos casos, consulta y recarga, en caso de un error se despliegan los mensajes adecuados mediante la interfaz de usuario y se reinicia la transacción.
Se despliegan mensajes de finalización de la transacción a través de la interfaz de usuario y se vuelve al inicio del programa a la espera de una nueva tarjeta.

\bigskip
De las funciones antes mencionadas, salvo l2\_init() y l3\_init(), todas fueron realizadas por el grupo de trabajo. Otras funciones de importancia realizadas por el grupo de trabajo son: autenticar(), que autentica con un sector específico de la tarjeta; leer\_tarjeta(), que lee un bloque de la tarjeta; escribir\_tarjeta(), que escribe un bloque de la tarjeta; entre otras.

\bigskip
\leftline{\bf{Demostración}}

Debido a que no se terminó de implementar el software de algunos de los módulos que conforman el sistema, esto se refiere a no haber culminado la integración entre el driver del lector/escritor de tarjetas de contacto con la biblioteca PCSC-Lite, y por otro lado la comunicación con un servidor (fuera del alcance del proyecto), fue necesario hacer algunas modificaciones en el código de la aplicación final con intenciones de suplir los faltantes antes mencionados.

\bigskip
\leftline{Cambios en la aplicación RF$ ^{2} $ para demo}

\bigskip
Comunicación con la tarjeta de contacto: En el directorio sam, dentro del archivo sam.c, se encuentra definida la función claves\_mifare() la cual devuelve las claves de la tarjeta sin contacto, a partir del pasaje del UID como parámetro de entrada a la función. Se modificó la función para que se seleccionen las claves a devolver según el UID pasado. Con ésto se logra simular una de las funcionalidades más importantes del \\
lector/escritor de tarjetas de contacto en la derivación de claves.

\bigskip
Comunicación con un servidor: En cierto momento de la transacción es necesario comunicarse con un servidor para saber si la tarjeta sin contacto implicada en la transacción, tiene o no saldo para recargar. Para simular la comunicación con el servidor, se creó un archivo de texto (independiente del código), donde cada fila se corresponde con una tarjeta de prueba. Esto es, en el renglón i, se encuentra el saldo a acreditar de la tarjeta de prueba i. El acceso a este archivo de texto se hace de forma local y la idea es que en caso que la tarjeta de prueba i, tenga saldo a recargar, luego de realizada la recarga se modifique el archivo de texto de forma que el nuevo saldo a recargar en la tarjeta i sea cero, esto último se realiza mediante la función reseteo\_recarga(). Lo anteriormente comentado, llevó a que se implementaran nuevas funciones para el acceso y modificación del archivo de texto. Las nuevas funciones implementadas se ubicaron dentro del directorio utiles y son: leer\_linea() y escribir\_linea(). Con ésto se logra simular la funcionalidad del servidor en cuanto a la recarga de tarjetas. Para agregar un nuevo saldo a recargar, solo basta con editar el archivo de texto. No es necesario parar la aplicación para editar el archivo de texto, ya que éste no es parte del código.